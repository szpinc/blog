{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/material/source/css/disqus-proxy.css","path":"css/disqus-proxy.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/duoshuo.css","path":"css/duoshuo.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/disqus-proxy.min.css","path":"css/disqus-proxy.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/duoshuo.min.css","path":"css/duoshuo.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/fontawesome.min.css","path":"css/fontawesome.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/gallery.min.css","path":"css/gallery.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/ie-blocker.css","path":"css/ie-blocker.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/material-icons.css","path":"css/material-icons.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify.css","path":"css/prettify.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify.min.css","path":"css/prettify.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/uc.css","path":"css/uc.css","modified":1,"renderable":1},{"_id":"themes/material/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/avatar.png.bak","path":"img/avatar.png.bak","modified":1,"renderable":1},{"_id":"themes/material/source/img/bg.png","path":"img/bg.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/browserstack_logo.png","path":"img/browserstack_logo.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/favicon.png.bak","path":"img/favicon.png.bak","modified":1,"renderable":1},{"_id":"themes/material/source/img/upyun_logo.svg","path":"img/upyun_logo.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/sidebar_header.png","path":"img/sidebar_header.png","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","path":"fonts/MaterialIcons-Regular.woff","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","path":"fonts/MaterialIcons-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/material/source/js/Valine.min.js","path":"js/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/hanabi-browser-bundle.js","path":"js/hanabi-browser-bundle.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/MathJax.js","path":"js/MathJax.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/ie-blocker.en.js","path":"js/ie-blocker.en.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","path":"js/ie-blocker.zhCN.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/lsloader.js","path":"js/lsloader.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/lsloader.min.js","path":"js/lsloader.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/nprogress.js","path":"js/nprogress.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/prettify.min.js","path":"js/prettify.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/queue.min.js","path":"js/queue.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/queue.js","path":"js/queue.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":1,"renderable":1},{"_id":"themes/material/source/css/material.css","path":"css/material.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/material.min.css","path":"css/material.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/style.min.css","path":"css/style.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/material/source/img/daily_pic.png","path":"img/daily_pic.png","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","path":"fonts/MaterialIcons-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/material/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/js.js","path":"js/js.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/js.min.js","path":"js/js.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-cave-dark.min.css","path":"css/prettify/atelier-cave-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-dune-dark.min.css","path":"css/prettify/atelier-dune-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-cave-light.min.css","path":"css/prettify/atelier-cave-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-dune-light.min.css","path":"css/prettify/atelier-dune-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-estuary-dark.min.css","path":"css/prettify/atelier-estuary-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-estuary-light.min.css","path":"css/prettify/atelier-estuary-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-forest-dark.min.css","path":"css/prettify/atelier-forest-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-forest-light.min.css","path":"css/prettify/atelier-forest-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-heath-dark.min.css","path":"css/prettify/atelier-heath-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-heath-light.min.css","path":"css/prettify/atelier-heath-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-lakeside-dark.min.css","path":"css/prettify/atelier-lakeside-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-lakeside-light.min.css","path":"css/prettify/atelier-lakeside-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-plateau-dark.min.css","path":"css/prettify/atelier-plateau-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-plateau-light.min.css","path":"css/prettify/atelier-plateau-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-savanna-dark.min.css","path":"css/prettify/atelier-savanna-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-savanna-light.min.css","path":"css/prettify/atelier-savanna-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-seaside-light.min.css","path":"css/prettify/atelier-seaside-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-seaside-dark.min.css","path":"css/prettify/atelier-seaside-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-dark.min.css","path":"css/prettify/atelier-sulphurpool-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/github-v2.min.css","path":"css/prettify/github-v2.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-light.min.css","path":"css/prettify/atelier-sulphurpool-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/github.min.css","path":"css/prettify/github.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/hemisu-dark.min.css","path":"css/prettify/hemisu-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/hemisu-light.min.css","path":"css/prettify/hemisu-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-blue.min.css","path":"css/prettify/tomorrow-night-blue.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-bright.min.css","path":"css/prettify/tomorrow-night-bright.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-eighties.min.css","path":"css/prettify/tomorrow-night-eighties.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night.min.css","path":"css/prettify/tomorrow-night.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow.min.css","path":"css/prettify/tomorrow.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tranquil-heart.min.css","path":"css/prettify/tranquil-heart.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/vibrant-ink.min.css","path":"css/prettify/vibrant-ink.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-bilibili.svg","path":"img/footer/footer_ico-bilibili.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/gallery/close.svg","path":"img/gallery/close.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/gallery/spinner.svg","path":"img/gallery/spinner.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/gallery/arrow.svg","path":"img/gallery/arrow.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-facebook.svg","path":"img/footer/footer_ico-facebook.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-gplus.svg","path":"img/footer/footer_ico-gplus.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-github.svg","path":"img/footer/footer_ico-github.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-instagram.svg","path":"img/footer/footer_ico-instagram.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-linkedin.svg","path":"img/footer/footer_ico-linkedin.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-telegram.svg","path":"img/footer/footer_ico-telegram.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.svg","path":"img/footer/footer_ico-tumblr.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-twitter.svg","path":"img/footer/footer_ico-twitter.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-v2ex.svg","path":"img/footer/footer_ico-v2ex.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-zhihu.svg","path":"img/footer/footer_ico-zhihu.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-weibo.svg","path":"img/footer/footer_ico-weibo.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-10.png","path":"img/random/material-10.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-12.png","path":"img/random/material-12.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-17.png","path":"img/random/material-17.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-19.png","path":"img/random/material-19.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-3.png","path":"img/random/material-3.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-4.png","path":"img/random/material-4.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-6.png","path":"img/random/material-6.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-8.png","path":"img/random/material-8.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-9.png","path":"img/random/material-9.png","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","path":"fonts/MaterialIcons-Regular.eot","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/js/gallery/gallery.js","path":"js/gallery/gallery.js","modified":1,"renderable":1},{"_id":"themes/material/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-1.png","path":"img/random/material-1.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-11.png","path":"img/random/material-11.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-13.png","path":"img/random/material-13.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-14.png","path":"img/random/material-14.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-15.png","path":"img/random/material-15.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-16.png","path":"img/random/material-16.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-18.png","path":"img/random/material-18.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-2.png","path":"img/random/material-2.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-5.png","path":"img/random/material-5.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-7.png","path":"img/random/material-7.png","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","path":"fonts/Roboto-Black.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","path":"fonts/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","path":"fonts/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","path":"fonts/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","path":"fonts/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","path":"fonts/Roboto-Thin.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"08336e9a913e75c66493826df158f75da2327cee","modified":1531209585591},{"_id":"themes/material/.travis.yml","hash":"10a09fe2b341ccad5b97d4bd9cc2c1c03e1863a3","modified":1531209585607},{"_id":"themes/material/_config.yml","hash":"12b8a6af390fb6eccd997b855924e11c08aeea8c","modified":1531209585607},{"_id":"themes/material/package.json","hash":"e00885ee25ac548685af9869cf4cf895118a744c","modified":1531209585700},{"_id":"source/_data/gallery.yaml","hash":"7baaec6290aff75ae1670e8e89235d20813eb330","modified":1531209585591},{"_id":"source/_data/links.yaml","hash":"5c7852aea8b38d30d9a9313c38a4a3baaa94a34c","modified":1531209585591},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1531209585591},{"_id":"source/_posts/Docker容器技术：初学笔记.md","hash":"73a926e14fc3f45334f192c3bb1e1afa9f472e6b","modified":1531209585591},{"_id":"source/_posts/HashMap中傻傻分不清楚的那些概念.md","hash":"862ffe2e5b66c78880366bc7555749e899e45a97","modified":1531209585591},{"_id":"source/_posts/SpringBoot入门最详细教程.md","hash":"122c5966cb45f82438f27489d679cca3c1262d1c","modified":1531209585591},{"_id":"source/_posts/Spring注解-Async和-Transactional失效问题究竟是什么原因，强势解释一波.md","hash":"4fbbbc744fd091b6016040061ed49b10fc65710c","modified":1531209585591},{"_id":"source/about/index.md","hash":"cce0b6fea169bfff1b47111ce52e1b22fae73f02","modified":1531209585591},{"_id":"source/_posts/分布式-dubbo-架构设计详解.md","hash":"883b69f5bbbbe033f1af1003d800b0292fa1393d","modified":1531209585591},{"_id":"source/_posts/搭建本地私有docker仓库.md","hash":"8f1aa80c73649fa8cb771ac6b08d10c5828d0f10","modified":1531209585591},{"_id":"source/gallery/index.md","hash":"3f863c7d536df27dc4f102602b2a67c4bafb2d03","modified":1531209585591},{"_id":"source/tags/index.md","hash":"b40cc7de78a512eac87ffebd83130e4aeb3442de","modified":1531209585607},{"_id":"source/links/index.md","hash":"33fb9ff5244c9b4a08afe3de43c2a51e779cce35","modified":1531209585591},{"_id":"source/timeline/index.md","hash":"eb7717a4362f548df8e340f0dec66ec84ee0cd87","modified":1531209585607},{"_id":"themes/material/languages/ar.yml","hash":"472d71f052e08f3c03b15dd67d11ad41f2eee7bf","modified":1531209585607},{"_id":"themes/material/languages/de.yml","hash":"bce37d066ffa82f3e249d41d0ee883c913cc2c5f","modified":1531209585607},{"_id":"themes/material/languages/en.yml","hash":"b59136a1b4d0a77e550b0e7e2e430cac44230dd3","modified":1531209585607},{"_id":"themes/material/languages/es.yml","hash":"d35f5411bc87277cc2d3a58d9499ddb9cfd46f1b","modified":1531209585607},{"_id":"themes/material/languages/fr.yml","hash":"f456cf31a72d97f2f18e3bb6cf735285d2b9d2c5","modified":1531209585607},{"_id":"themes/material/languages/ja.yml","hash":"768b8330c9c73287efd475e68741ce4ebad29fd1","modified":1531209585607},{"_id":"themes/material/languages/ms.yml","hash":"237a39bbfcce33e7b918f6c5dc0f01bc79900262","modified":1531209585607},{"_id":"themes/material/languages/nl_NL.yml","hash":"b71e59807716185627d6b9b84e44a79401df639f","modified":1531209585607},{"_id":"themes/material/languages/pt-BR.yml","hash":"a070c2c4d0d3d54f8ca70513cff73c3f7c306db1","modified":1531209585622},{"_id":"themes/material/languages/ru.yml","hash":"fbff2cf48dbde45adcad781e2fd6c30b523a4ac1","modified":1531209585622},{"_id":"themes/material/languages/zh-CN.yml","hash":"c188cad1a16ab0651e2d2d03cb3fa79962cf65ff","modified":1531209585622},{"_id":"themes/material/languages/zh-TW.yml","hash":"ec55953f0330f81bf1ffb37ff34de258dfda642a","modified":1531209585622},{"_id":"themes/material/layout/index.ejs","hash":"aca1abb741f891776913c8ea2e6ff626a0ea5736","modified":1531209585685},{"_id":"themes/material/layout/layout.ejs","hash":"ea811e2dc752e131a18dd999f2f1f4addb4b48bb","modified":1531209585685},{"_id":"themes/material/layout/post.ejs","hash":"4dd572a9e84f3a6baa5e3f16d270e58e3cd31a23","modified":1531209585700},{"_id":"themes/material/scripts/helper.js","hash":"e7111a8b1f0ab5bf3466378c48c260a4f6e527d6","modified":1531209585700},{"_id":"themes/material/source/.DS_Store","hash":"27508d3707e74cfcc80fcc43ea57d7b3212ddb79","modified":1531209585700},{"_id":"themes/material/layout/_partial/Isolation-post-info.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1531209585638},{"_id":"themes/material/scripts/lib/font_lsload.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1531209585700},{"_id":"themes/material/layout/_partial/Isolation-post_entry.ejs","hash":"134dc82320b7aed7d4d78960be63e16c5c4a30fb","modified":1531209585638},{"_id":"themes/material/layout/_partial/Paradox-post-thumbnail.ejs","hash":"6f1e9a85c089ce98a36a2954839fb9ce3e53739e","modified":1531209585638},{"_id":"themes/material/layout/_partial/Paradox-post-info.ejs","hash":"125cfa5cd9e6e1ca5e958026fdd42f3c3141e34f","modified":1531209585638},{"_id":"themes/material/layout/_partial/Paradox-post_entry-thumbnail.ejs","hash":"4d740eba338517d4e10d011a157cdefad45a8e1f","modified":1531209585638},{"_id":"themes/material/layout/_partial/Paradox-post_entry.ejs","hash":"5f4d67e5bd70f635203706cf344b036d891073e6","modified":1531209585638},{"_id":"themes/material/layout/_partial/Paradox-search.ejs","hash":"18a6971b04feccd124a096b8c7cecf1fd4bb914e","modified":1531209585638},{"_id":"themes/material/layout/_partial/blog_info.ejs","hash":"5e95796e6f9a81163554ca4198573860f7328d4e","modified":1531209585622},{"_id":"themes/material/layout/_partial/config_css.ejs","hash":"f91fa273beb8a8c884529df77b7cae14e7200b37","modified":1531209585622},{"_id":"themes/material/layout/_partial/comment.ejs","hash":"c9fb1f98a18ca484cb52d60e2ad2bad25b56dfb2","modified":1531209585622},{"_id":"themes/material/layout/_partial/config_font.ejs","hash":"730abeb681758ce288d5541930c46bc4b041a0b1","modified":1531209585622},{"_id":"themes/material/layout/_partial/footer-left.ejs","hash":"372cdf718e01fea2736b8e427e57bfcfaa8a557f","modified":1531209585622},{"_id":"themes/material/layout/_partial/daily_pic.ejs","hash":"e780fbdb79b5e27091c408545cfd5b64892c9b01","modified":1531209585622},{"_id":"themes/material/layout/_partial/footer-option.ejs","hash":"be20394eaeaf2d20db28946b948962c839da6ea9","modified":1531209585622},{"_id":"themes/material/layout/_partial/footer_top.ejs","hash":"9eaace4feb951c96c0033e7271497f3f300d2476","modified":1531209585622},{"_id":"themes/material/layout/_partial/footer.ejs","hash":"530626c347882579d09d71df68993e25076ca8e2","modified":1531209585622},{"_id":"themes/material/layout/_partial/head.ejs","hash":"8167f995c7cc21a6a8ddbfbdd03f2f74a7bd904d","modified":1531209585622},{"_id":"themes/material/layout/_partial/import_js.ejs","hash":"961b8a0059875e4044fe80bbe91ca6a225f113e5","modified":1531209585622},{"_id":"themes/material/layout/_partial/isolate-sns_list.ejs","hash":"fc5f03ebb847f85975676a9dfee8870e7c908008","modified":1531209585638},{"_id":"themes/material/layout/_partial/isolate_info.ejs","hash":"95efc3745f6fa49cd18de08b2be21d369a09bb95","modified":1531209585638},{"_id":"themes/material/layout/_partial/post-content.ejs","hash":"ad626e3b60bc4a17bacff02cf9b0a8beaba2ad1e","modified":1531209585638},{"_id":"themes/material/layout/_partial/post-header.ejs","hash":"b0b8973c48db6376a24d4b4b1d2eb15d18d6508c","modified":1531209585638},{"_id":"themes/material/layout/_partial/post-info-share.ejs","hash":"9f28d62bf728c2bd89411688426a65d7ee55400c","modified":1531209585638},{"_id":"themes/material/layout/_partial/sidebar-footer.ejs","hash":"ee0977b548650c2b872662ae1e06d0c4d44e11cf","modified":1531209585638},{"_id":"themes/material/layout/_partial/post-nav.ejs","hash":"3b6d4568cc46f60c697ad9ec85a4aa5971f3eecc","modified":1531209585638},{"_id":"themes/material/layout/_partial/sidebar-header.ejs","hash":"06295e01092f55504d30a343c3fdc5091280e495","modified":1531209585638},{"_id":"themes/material/layout/_partial/sidebar-footer_image.ejs","hash":"b9157d2072028a1db3c3419f76bde6637e85cf0e","modified":1531209585638},{"_id":"themes/material/layout/_partial/sidebar-navigation.ejs","hash":"ff44901fdfdd952174b0d22e86df7163d7fba9ba","modified":1531209585638},{"_id":"themes/material/layout/_partial/sidebar.ejs","hash":"c5ce6136e82895cb80dab8a918a7cdf2fe820fea","modified":1531209585654},{"_id":"themes/material/layout/_partial/structured-data.ejs","hash":"e845df290185dc300cc4edcc08b50fddc5b6909b","modified":1531209585654},{"_id":"themes/material/layout/_partial/toc_button.ejs","hash":"688c3fc12e2548ff27fe60688f79dcce2881fd50","modified":1531209585654},{"_id":"themes/material/layout/_widget/dnsprefetch.ejs","hash":"5e4c5359d69a64042183db13f6dd771b1f7f6b31","modified":1531209585685},{"_id":"themes/material/layout/_widget/leancloud-like.ejs","hash":"e4780fe3bbb049db38d694fc18dee13d799bd51d","modified":1531209585685},{"_id":"themes/material/layout/_widget/leancloud-views_num.ejs","hash":"e27baba6a2de406463735d276606b15fb40f5eba","modified":1531209585685},{"_id":"themes/material/layout/_widget/leancloud-views.ejs","hash":"211dc183b8e84f71b2c25b3ac6659d162d81662b","modified":1531209585685},{"_id":"themes/material/layout/_widget/mathjax.ejs","hash":"b68befe1fea84739c8429c344e570a8bc0357401","modified":1531209585685},{"_id":"themes/material/layout/_widget/nprogress.ejs","hash":"901a64600854b312209287c702278183600e06b9","modified":1531209585685},{"_id":"themes/material/layout/_widget/page-gallery.ejs","hash":"81b9410deef7a83ef5bc7cd18ad042df70d70b94","modified":1531209585685},{"_id":"themes/material/layout/_widget/page-links.ejs","hash":"0ebe18e4326f921d6010df8479a08c2d403ba717","modified":1531209585685},{"_id":"themes/material/layout/_widget/page-tagcloud.ejs","hash":"e71de74e4067cc4e6aef1e09ac429c92bcd178b3","modified":1531209585685},{"_id":"themes/material/layout/_widget/page-timeline.ejs","hash":"9fa0195e08d9fd40aa0333e9279c98bc65acf604","modified":1531209585685},{"_id":"themes/material/layout/_widget/qrcode.ejs","hash":"3212e5d29fe8490c5d9a844ec9c2ce9925532de8","modified":1531209585685},{"_id":"themes/material/layout/_widget/search-local-js.ejs","hash":"f42cc040adf47fc7d74f64b0be3c3230e8a3339e","modified":1531209585685},{"_id":"themes/material/layout/_widget/search-swiftype-js.ejs","hash":"7ad1e843e620ccd9b3c041dccfdcee97921247a1","modified":1531209585685},{"_id":"themes/material/scripts/lib/css_lsload.js","hash":"179f5f5e3297a7fb7d90545ddd94eb468a11046e","modified":1531209585700},{"_id":"themes/material/scripts/lib/js_hex.js","hash":"2704583aa036d538544ce31c2e924c0c125309dd","modified":1531209585700},{"_id":"themes/material/scripts/lib/get_file_hex.js","hash":"eb3b9a45f8ca45ef40d5421baef7d4484023982c","modified":1531209585700},{"_id":"themes/material/scripts/lib/path_for.js","hash":"f944e3b53a468962121aa3357cc0bc18ac27a34c","modified":1531209585700},{"_id":"themes/material/scripts/lib/js_lsload.js","hash":"72f885b13fe0028a0e2acb7168dcc66e39ea1592","modified":1531209585700},{"_id":"themes/material/source/css/disqus-proxy.css","hash":"770776d8cec27cd5661bdfd59eff9af263439989","modified":1531209585716},{"_id":"themes/material/source/css/.DS_Store","hash":"09782ef5026e8d67b2b94b469b8b9345453abbc8","modified":1531209585700},{"_id":"themes/material/source/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1531209585716},{"_id":"themes/material/source/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1531209585716},{"_id":"themes/material/source/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1531209585716},{"_id":"themes/material/source/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1531209585716},{"_id":"themes/material/source/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1531209585716},{"_id":"themes/material/source/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1531209585716},{"_id":"themes/material/source/css/material-icons.css","hash":"f6f95fe5190f3c65931847246621fb83754eb00c","modified":1531209585716},{"_id":"themes/material/source/css/prettify.css","hash":"c395f20ee64e80c2b6b15c7dade02f9aaaeab2c8","modified":1531209585747},{"_id":"themes/material/source/css/prettify.min.css","hash":"62edd8f08656463b0e077dcf893faa3cc8eb5fe4","modified":1531209585747},{"_id":"themes/material/source/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1531209585747},{"_id":"themes/material/source/img/avatar.png","hash":"0ce06b25d0d38dce0c7fceea7134aefce5444268","modified":1531209585779},{"_id":"themes/material/source/img/avatar.png.bak","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1531209585779},{"_id":"themes/material/source/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1531209585779},{"_id":"themes/material/source/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1531209585779},{"_id":"themes/material/source/img/favicon.png.bak","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1531209585779},{"_id":"themes/material/source/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1531209585825},{"_id":"themes/material/source/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1531209585810},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1531209585763},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1531209585763},{"_id":"themes/material/source/js/Valine.min.js","hash":"6a287a99a772a0ea8f98b133523429c9250cc67f","modified":1531209585841},{"_id":"themes/material/source/js/hanabi-browser-bundle.js","hash":"d646647bda386140c8315d60e3ff4ddbdb15c1ea","modified":1531209585825},{"_id":"themes/material/source/js/MathJax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1531209585825},{"_id":"themes/material/source/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1531209585825},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1531209585825},{"_id":"themes/material/source/js/lsloader.js","hash":"2b14e57784fb6b5f58d71584189c61af45f393e8","modified":1531209585825},{"_id":"themes/material/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1531209585825},{"_id":"themes/material/source/js/lsloader.min.js","hash":"1a68a8d267948ea8475245b7d365a1a1bd8f732e","modified":1531209585825},{"_id":"themes/material/source/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1531209585825},{"_id":"themes/material/source/js/prettify.min.js","hash":"69908fe0a09cee107c25cb5d769b861723e7b7bb","modified":1531209585825},{"_id":"themes/material/source/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1531209585841},{"_id":"themes/material/source/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1531209585825},{"_id":"themes/material/source/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1531209585841},{"_id":"themes/material/source/css/material.css","hash":"068e2b00f686157b6e8b78b9b808112adbedf4de","modified":1531209585716},{"_id":"themes/material/source/css/material.min.css","hash":"1a19febb9214ab689b02f5bb8ccb23579e6c1181","modified":1531209585716},{"_id":"themes/material/source/css/style.min.css","hash":"a9e9b33e1fcf818f08a04b909c86f2460a05f060","modified":1531209585747},{"_id":"themes/material/source/css/style.css","hash":"95749779bcb6e0466f51b686cf34163eaf90bfa7","modified":1531209585747},{"_id":"themes/material/source/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1531209585779},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1531209585763},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1531209585763},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1531209585763},{"_id":"themes/material/source/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1531209585825},{"_id":"themes/material/source/js/js.js","hash":"d919314cdfe92664462d67738ff9f4aaad0afb8c","modified":1531209585825},{"_id":"themes/material/source/js/js.min.js","hash":"6e3fb908ed653bfbef5d2b9cbadd6c56187f4e1a","modified":1531209585825},{"_id":"themes/material/layout/_widget/analytics/baidu-analytics.ejs","hash":"3866a7fead3c1f94a517f1f9d629f092670b1520","modified":1531209585654},{"_id":"themes/material/layout/_widget/analytics/cnzz-analytics.ejs","hash":"1765e3dcd92961292f40d1812e593186c77b17ef","modified":1531209585654},{"_id":"themes/material/layout/_widget/analytics/google-analytics.ejs","hash":"3b10ebf524baf0c24b22dcd110b39d15c5acb9b5","modified":1531209585654},{"_id":"themes/material/source/css/prettify/.DS_Store","hash":"8cf148f8c83b7c2ab860771d5c136e71cd99b132","modified":1531209585716},{"_id":"themes/material/source/css/prettify/atelier-cave-dark.min.css","hash":"cb0156cdc36500a26b232ae1c81fdc880eba85e7","modified":1531209585716},{"_id":"themes/material/source/css/prettify/atelier-dune-dark.min.css","hash":"c5094d99ca0e619d97860c88211bf908fdf830b1","modified":1531209585716},{"_id":"themes/material/source/css/prettify/atelier-cave-light.min.css","hash":"4b62dc45aa351b071d6a434dc54fe8c2e15c85cc","modified":1531209585716},{"_id":"themes/material/source/css/prettify/atelier-dune-light.min.css","hash":"b3ad98483e4d5bde72d52a15423d98e0d086db09","modified":1531209585716},{"_id":"themes/material/source/css/prettify/atelier-estuary-dark.min.css","hash":"7e3a065cafeb3acc1d7178f64ef4265f5d5ad2b9","modified":1531209585716},{"_id":"themes/material/source/css/prettify/atelier-estuary-light.min.css","hash":"1d12d8f7fa9c122a186ee76fdf681c191a68f104","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-forest-dark.min.css","hash":"9296b851a5b66785a60afa5da5fe9080bda96bf5","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-forest-light.min.css","hash":"3532f6e86bf4afbba05f7a074b791b73174f9622","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-heath-dark.min.css","hash":"954309acd7918422382a3ff2f9c2988aec0ff956","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-heath-light.min.css","hash":"a67199fa580b3aa2df031e5d2028929d29ca3b45","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-lakeside-dark.min.css","hash":"18575fc6dff855e395a39d0383d2f18807091f0d","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-lakeside-light.min.css","hash":"e20e8ac64432fa1aa6f74792b58196af7cf79c12","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-plateau-dark.min.css","hash":"137e3c499a720da3c1d57b4dc53264b1d623e1c5","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-plateau-light.min.css","hash":"153801640fdcbb74c0de3f15345110f2210eb991","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-savanna-dark.min.css","hash":"fba92c652fd6704422b8f2bbc11706805a6faed0","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-savanna-light.min.css","hash":"d9425ffb7c60d646190c22b9a5f72091ee5f9ace","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-seaside-light.min.css","hash":"732750b75389c1c49204f37705e6abeee40ce64f","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-seaside-dark.min.css","hash":"e0e6bbacc75a349b1e49c236d374b0e42f1fd485","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-dark.min.css","hash":"015a35dddaee153fa8bb71d7f3818a6ba4d120d8","modified":1531209585732},{"_id":"themes/material/source/css/prettify/github-v2.min.css","hash":"57630621d20842a529bdea7b17fc90f520e562ef","modified":1531209585732},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-light.min.css","hash":"ab1a6200eab648cab443c3df77fde9b237ef27b6","modified":1531209585732},{"_id":"themes/material/source/css/prettify/github.min.css","hash":"19cf828225288fa5c006f1d8f66c39d11f4ef7f2","modified":1531209585747},{"_id":"themes/material/source/css/prettify/hemisu-dark.min.css","hash":"a671248cfd573292026d2174817e82e593691052","modified":1531209585747},{"_id":"themes/material/source/css/prettify/hemisu-light.min.css","hash":"b2556ff41e513fd13d032ec84a37ee260a905815","modified":1531209585747},{"_id":"themes/material/source/css/prettify/tomorrow-night-blue.min.css","hash":"c442728d96485bcf816151fe6bd96993aae09852","modified":1531209585747},{"_id":"themes/material/source/css/prettify/tomorrow-night-bright.min.css","hash":"cf251fd3edfd736695272a0f1b41d509b7bb1fb9","modified":1531209585747},{"_id":"themes/material/source/css/prettify/tomorrow-night-eighties.min.css","hash":"6ce259d674bb4edda23eea32b2379be17d0e0e6e","modified":1531209585747},{"_id":"themes/material/source/css/prettify/tomorrow-night.min.css","hash":"d989206d124035494acb4b0cdc7fbc89f3b7d108","modified":1531209585747},{"_id":"themes/material/source/css/prettify/tomorrow.min.css","hash":"b2c6d610b77f0273fefab5aa4ad26a7f58956f87","modified":1531209585747},{"_id":"themes/material/source/css/prettify/tranquil-heart.min.css","hash":"0f6eefbdda8e410832e9c516a5dd19899217ef06","modified":1531209585747},{"_id":"themes/material/source/css/prettify/vibrant-ink.min.css","hash":"c265bac6c31cf622b536b29c8a6bc46955d6fe63","modified":1531209585747},{"_id":"themes/material/source/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1531209585779},{"_id":"themes/material/source/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1531209585794},{"_id":"themes/material/source/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1531209585794},{"_id":"themes/material/source/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1531209585794},{"_id":"themes/material/source/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1531209585779},{"_id":"themes/material/source/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1531209585779},{"_id":"themes/material/source/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1531209585779},{"_id":"themes/material/source/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1531209585779},{"_id":"themes/material/source/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1531209585794},{"_id":"themes/material/source/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1531209585794},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1531209585794},{"_id":"themes/material/source/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1531209585794},{"_id":"themes/material/source/img/footer/footer_ico-v2ex.svg","hash":"c5ffaf67a97e534c266d1585a9a3b56f1bfe3052","modified":1531209585794},{"_id":"themes/material/source/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1531209585794},{"_id":"themes/material/source/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1531209585794},{"_id":"themes/material/source/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1531209585794},{"_id":"themes/material/source/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1531209585794},{"_id":"themes/material/source/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1531209585810},{"_id":"themes/material/source/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1531209585810},{"_id":"themes/material/source/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1531209585810},{"_id":"themes/material/source/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1531209585810},{"_id":"themes/material/source/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1531209585810},{"_id":"themes/material/source/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1531209585810},{"_id":"themes/material/source/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1531209585810},{"_id":"themes/material/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1531209585763},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1531209585763},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1531209585763},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1531209585763},{"_id":"themes/material/source/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1531209585825},{"_id":"themes/material/layout/_widget/comment/livere/common.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/valine/common.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1531209585669},{"_id":"themes/material/source/img/favicon.png","hash":"99c7ea94e9346b9b8fe61e8eca515d305f96f349","modified":1531209585779},{"_id":"themes/material/source/img/logo.png","hash":"99c7ea94e9346b9b8fe61e8eca515d305f96f349","modified":1531209585794},{"_id":"themes/material/source/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1531209585794},{"_id":"themes/material/source/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1531209585794},{"_id":"themes/material/source/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1531209585810},{"_id":"themes/material/source/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1531209585810},{"_id":"themes/material/source/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1531209585810},{"_id":"themes/material/source/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1531209585810},{"_id":"themes/material/source/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1531209585810},{"_id":"themes/material/source/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1531209585810},{"_id":"themes/material/source/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1531209585810},{"_id":"themes/material/source/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1531209585810},{"_id":"themes/material/layout/_widget/comment/changyan/enter.ejs","hash":"e3cfb4f37ea35457f112f3e822e130c930086497","modified":1531209585654},{"_id":"themes/material/layout/_widget/comment/changyan/common.ejs","hash":"40e1fc76d6b7f64e226693fb2fe1a6bb17bae245","modified":1531209585654},{"_id":"themes/material/layout/_widget/comment/disqus_click/common.ejs","hash":"d243f576b366a62191066459efcc6fd0ab79d00a","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/changyan/main.ejs","hash":"77539ff32cc9d1204b848e01b5277fff5cbd61e0","modified":1531209585654},{"_id":"themes/material/layout/_widget/comment/disqus_click/enter.ejs","hash":"d82f0296f8bae25223ec44e6e05b817d3a234884","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/disqus_click/main.ejs","hash":"f53de208ca46c669a868a1922488e39509c6fe3b","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/disqus/common.ejs","hash":"c11cfceb0906a96399dede5da01ff7fe4787f8a5","modified":1531209585654},{"_id":"themes/material/layout/_widget/comment/disqus/enter.ejs","hash":"39192034766349e47967da63184f9104fdded2ab","modified":1531209585654},{"_id":"themes/material/layout/_widget/comment/disqus/main.ejs","hash":"21e0eeff664191b818d7a0071ae7edcdfc270442","modified":1531209585654},{"_id":"themes/material/layout/_widget/comment/gitalk/common.ejs","hash":"f739897518011e1b3de7807c8c5d734984711282","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/gitalk/enter.ejs","hash":"4d70d76465469a57def29a221962a5520fb34ebe","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/gitalk/main.ejs","hash":"1ee7a7b2b9b5ae8c4fa8c4b09c7973b9e085bdf2","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/gitment/common.ejs","hash":"9c6c8d1b448c32afb01c2d0351e87f4d4a17ec3c","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/gitment/enter.ejs","hash":"46d904fde9233694b95c6a3d91b9a2b7a6805850","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/gitment/main.ejs","hash":"e622660eda38cda05847aadc2a3e31a228fc519b","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/livere/enter.ejs","hash":"194b7bb581a3b8608a7ab135b6953d7908f51cc8","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/livere/main.ejs","hash":"1c4be9ba104a8cbcc11d45f11bf8cfe7704b93a5","modified":1531209585669},{"_id":"themes/material/layout/_widget/comment/valine/enter.ejs","hash":"ab528aad46237d9e7f1c5b4b2b310dd628b2de63","modified":1531209585685},{"_id":"themes/material/layout/_widget/comment/valine/main.ejs","hash":"3d5d8559e6ad4ffb58a61d96439b2718eb9999b6","modified":1531209585685},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1531209585763},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1531209585763},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1531209585763},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1531209585763},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1531209585763},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1531209585779},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1531209585779},{"_id":"public/search.xml","hash":"3358b083788509d2c380655fa5ed4867008674d6","modified":1531227965692},{"_id":"public/about/index.html","hash":"f39f52e20a39a94a8fe3d0b790a6b60877646ada","modified":1531227965962},{"_id":"public/gallery/index.html","hash":"69d725613d8d2661227c5a677c9fd583184ab7e0","modified":1531227965962},{"_id":"public/tags/index.html","hash":"36084fe7f3c9b66d7b1035f18bdaa13202856f33","modified":1531227965962},{"_id":"public/links/index.html","hash":"d5403def2a9594ef94f59da50091a320c8f9a61c","modified":1531227965962},{"_id":"public/timeline/index.html","hash":"7e96ec423e53fb29e578b033fd7240ced4c070da","modified":1531227965962},{"_id":"public/2017/06/29/分布式-dubbo-架构设计详解/index.html","hash":"65b84976f564c5be4393185a0611cba228ee0e49","modified":1531227965962},{"_id":"public/2017/07/01/Spring注解-Async和-Transactional失效问题究竟是什么原因，强势解释一波/index.html","hash":"e32c678f5b57554bbe4caf40c45c86eef91a3def","modified":1531227965963},{"_id":"public/2017/06/28/HashMap中傻傻分不清楚的那些概念/index.html","hash":"1524d68ee6f7055f09d60265a2866014806a2a9b","modified":1531227965963},{"_id":"public/2017/06/27/SpringBoot入门最详细教程/index.html","hash":"ce84cc86819d42c56fde048256a24ff158615ba5","modified":1531227965963},{"_id":"public/2017/06/27/搭建本地私有docker仓库/index.html","hash":"01c9c9cc6c089867552c076ca3f29625117ff195","modified":1531227965963},{"_id":"public/2017/06/27/Docker容器技术：初学笔记/index.html","hash":"8fba446221d9146294155863ab1c58812a2c027a","modified":1531227965963},{"_id":"public/archives/index.html","hash":"b79f2d0c9d0d4519af16c6056dcaaabacbe5dfb3","modified":1531227965963},{"_id":"public/archives/2017/index.html","hash":"715c108315f40f9009ef6b42f39f1413d13ed97f","modified":1531227965963},{"_id":"public/archives/2017/06/index.html","hash":"690145ca298b37d6164fc71e6f6e4e2de8cf1d3c","modified":1531227965963},{"_id":"public/archives/2017/07/index.html","hash":"f8d9c1137d0b6dcf6ab7a197566d65b27f5d2d90","modified":1531227965963},{"_id":"public/index.html","hash":"1d44aea4567faaa03b1e978f4a7c66a6f7efc51a","modified":1531227965963},{"_id":"public/categories/学习笔记/index.html","hash":"a2f33d69c8627d41fb326c549067cdee216817c9","modified":1531227965963},{"_id":"public/categories/java/index.html","hash":"bbe5e9f7b0cd9152796e092b49538812fa2078ef","modified":1531227965964},{"_id":"public/categories/java/学习笔记/index.html","hash":"6218a86b5eb9db73c4ee678c0edc39abc97be793","modified":1531227965964},{"_id":"public/categories/学习笔记/java学习笔记/index.html","hash":"a93cde7a47aec0002e90a269087172b5b77b0d53","modified":1531227965964},{"_id":"public/tags/Docker/index.html","hash":"6c056e6fafb271cd872a7fc27524a143172f480e","modified":1531227965964},{"_id":"public/tags/云计算/index.html","hash":"4712f752c04f3c20c27b0979ae994871916fe2d5","modified":1531227965964},{"_id":"public/tags/大数据/index.html","hash":"8445385beeecd48bca66ed80d4a99538b753dd4b","modified":1531227965964},{"_id":"public/tags/java/index.html","hash":"1f9daa55bc14b513d13c46845f8c77fbec08a079","modified":1531227965964},{"_id":"public/tags/springboot/index.html","hash":"e4408715c1dc2b93ba04082c912d7c6b1d6893f6","modified":1531227965964},{"_id":"public/tags/spring/index.html","hash":"c969a364d15e063033c12efe01c2c5f6a58b04c1","modified":1531227965964},{"_id":"public/tags/微服务/index.html","hash":"156b7fa1791a82f408ee957d2da3347a02952e41","modified":1531227965964},{"_id":"public/tags/dubbo/index.html","hash":"c138e2694378763f2ed304e4f450097b80024478","modified":1531227965964},{"_id":"public/img/avatar.png.bak","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1531227965964},{"_id":"public/img/avatar.png","hash":"0ce06b25d0d38dce0c7fceea7134aefce5444268","modified":1531227965965},{"_id":"public/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1531227965965},{"_id":"public/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1531227965965},{"_id":"public/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1531227965965},{"_id":"public/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1531227965965},{"_id":"public/img/favicon.png.bak","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1531227965965},{"_id":"public/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1531227965965},{"_id":"public/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1531227965965},{"_id":"public/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1531227965976},{"_id":"public/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1531227965976},{"_id":"public/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1531227965977},{"_id":"public/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1531227965977},{"_id":"public/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1531227965977},{"_id":"public/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1531227965977},{"_id":"public/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1531227965977},{"_id":"public/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1531227965977},{"_id":"public/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1531227965977},{"_id":"public/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1531227965977},{"_id":"public/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1531227965978},{"_id":"public/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1531227965978},{"_id":"public/img/footer/footer_ico-v2ex.svg","hash":"c5ffaf67a97e534c266d1585a9a3b56f1bfe3052","modified":1531227965978},{"_id":"public/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1531227965978},{"_id":"public/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1531227965978},{"_id":"public/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1531227965978},{"_id":"public/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1531227965978},{"_id":"public/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1531227965978},{"_id":"public/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1531227965978},{"_id":"public/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1531227965978},{"_id":"public/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1531227965978},{"_id":"public/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1531227965979},{"_id":"public/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1531227965979},{"_id":"public/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1531227965979},{"_id":"public/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1531227965985},{"_id":"public/css/prettify.css","hash":"c395f20ee64e80c2b6b15c7dade02f9aaaeab2c8","modified":1531227965986},{"_id":"public/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1531227965987},{"_id":"public/css/prettify.min.css","hash":"62edd8f08656463b0e077dcf893faa3cc8eb5fe4","modified":1531227965987},{"_id":"public/js/hanabi-browser-bundle.js","hash":"d646647bda386140c8315d60e3ff4ddbdb15c1ea","modified":1531227965987},{"_id":"public/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1531227965987},{"_id":"public/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1531227965987},{"_id":"public/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1531227965987},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1531227965987},{"_id":"public/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1531227965987},{"_id":"public/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1531227965988},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1531227965988},{"_id":"public/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1531227965988},{"_id":"public/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1531227965988},{"_id":"public/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1531227965988},{"_id":"public/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1531227965988},{"_id":"public/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1531227965988},{"_id":"public/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1531227965989},{"_id":"public/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1531227965989},{"_id":"public/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1531227965989},{"_id":"public/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1531227965989},{"_id":"public/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1531227965989},{"_id":"public/js/lsloader.min.js","hash":"1a68a8d267948ea8475245b7d365a1a1bd8f732e","modified":1531227966004},{"_id":"public/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1531227966004},{"_id":"public/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1531227966005},{"_id":"public/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1531227966005},{"_id":"public/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1531227966005},{"_id":"public/css/prettify/atelier-cave-dark.min.css","hash":"cb0156cdc36500a26b232ae1c81fdc880eba85e7","modified":1531227966006},{"_id":"public/css/prettify/atelier-cave-light.min.css","hash":"4b62dc45aa351b071d6a434dc54fe8c2e15c85cc","modified":1531227966006},{"_id":"public/css/prettify/atelier-dune-light.min.css","hash":"b3ad98483e4d5bde72d52a15423d98e0d086db09","modified":1531227966006},{"_id":"public/css/prettify/atelier-estuary-dark.min.css","hash":"7e3a065cafeb3acc1d7178f64ef4265f5d5ad2b9","modified":1531227966006},{"_id":"public/css/prettify/atelier-dune-dark.min.css","hash":"c5094d99ca0e619d97860c88211bf908fdf830b1","modified":1531227966006},{"_id":"public/css/prettify/atelier-estuary-light.min.css","hash":"1d12d8f7fa9c122a186ee76fdf681c191a68f104","modified":1531227966006},{"_id":"public/css/prettify/atelier-forest-dark.min.css","hash":"9296b851a5b66785a60afa5da5fe9080bda96bf5","modified":1531227966006},{"_id":"public/css/prettify/atelier-forest-light.min.css","hash":"3532f6e86bf4afbba05f7a074b791b73174f9622","modified":1531227966006},{"_id":"public/css/prettify/atelier-heath-dark.min.css","hash":"954309acd7918422382a3ff2f9c2988aec0ff956","modified":1531227966006},{"_id":"public/css/prettify/atelier-lakeside-light.min.css","hash":"e20e8ac64432fa1aa6f74792b58196af7cf79c12","modified":1531227966007},{"_id":"public/css/prettify/atelier-lakeside-dark.min.css","hash":"18575fc6dff855e395a39d0383d2f18807091f0d","modified":1531227966007},{"_id":"public/css/prettify/atelier-plateau-dark.min.css","hash":"137e3c499a720da3c1d57b4dc53264b1d623e1c5","modified":1531227966007},{"_id":"public/css/prettify/atelier-heath-light.min.css","hash":"a67199fa580b3aa2df031e5d2028929d29ca3b45","modified":1531227966007},{"_id":"public/css/prettify/atelier-savanna-dark.min.css","hash":"fba92c652fd6704422b8f2bbc11706805a6faed0","modified":1531227966007},{"_id":"public/css/prettify/atelier-plateau-light.min.css","hash":"153801640fdcbb74c0de3f15345110f2210eb991","modified":1531227966007},{"_id":"public/css/prettify/atelier-seaside-dark.min.css","hash":"e0e6bbacc75a349b1e49c236d374b0e42f1fd485","modified":1531227966007},{"_id":"public/css/prettify/atelier-savanna-light.min.css","hash":"d9425ffb7c60d646190c22b9a5f72091ee5f9ace","modified":1531227966007},{"_id":"public/css/prettify/atelier-seaside-light.min.css","hash":"732750b75389c1c49204f37705e6abeee40ce64f","modified":1531227966008},{"_id":"public/css/prettify/atelier-sulphurpool-dark.min.css","hash":"015a35dddaee153fa8bb71d7f3818a6ba4d120d8","modified":1531227966008},{"_id":"public/css/prettify/github-v2.min.css","hash":"57630621d20842a529bdea7b17fc90f520e562ef","modified":1531227966008},{"_id":"public/css/prettify/atelier-sulphurpool-light.min.css","hash":"ab1a6200eab648cab443c3df77fde9b237ef27b6","modified":1531227966009},{"_id":"public/css/prettify/hemisu-light.min.css","hash":"b2556ff41e513fd13d032ec84a37ee260a905815","modified":1531227966009},{"_id":"public/css/prettify/github.min.css","hash":"19cf828225288fa5c006f1d8f66c39d11f4ef7f2","modified":1531227966009},{"_id":"public/css/prettify/tomorrow-night-blue.min.css","hash":"c442728d96485bcf816151fe6bd96993aae09852","modified":1531227966009},{"_id":"public/css/prettify/tomorrow.min.css","hash":"b2c6d610b77f0273fefab5aa4ad26a7f58956f87","modified":1531227966009},{"_id":"public/css/prettify/hemisu-dark.min.css","hash":"a671248cfd573292026d2174817e82e593691052","modified":1531227966009},{"_id":"public/css/prettify/tomorrow-night-bright.min.css","hash":"cf251fd3edfd736695272a0f1b41d509b7bb1fb9","modified":1531227966009},{"_id":"public/css/prettify/tomorrow-night.min.css","hash":"d989206d124035494acb4b0cdc7fbc89f3b7d108","modified":1531227966009},{"_id":"public/css/prettify/tomorrow-night-eighties.min.css","hash":"6ce259d674bb4edda23eea32b2379be17d0e0e6e","modified":1531227966009},{"_id":"public/css/prettify/tranquil-heart.min.css","hash":"0f6eefbdda8e410832e9c516a5dd19899217ef06","modified":1531227966009},{"_id":"public/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1531227966009},{"_id":"public/css/prettify/vibrant-ink.min.css","hash":"c265bac6c31cf622b536b29c8a6bc46955d6fe63","modified":1531227966009},{"_id":"public/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1531227966010},{"_id":"public/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1531227966010},{"_id":"public/js/lsloader.js","hash":"2b14e57784fb6b5f58d71584189c61af45f393e8","modified":1531227966010},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1531227966010},{"_id":"public/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1531227966010},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1531227966010},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1531227966010},{"_id":"public/js/prettify.min.js","hash":"69908fe0a09cee107c25cb5d769b861723e7b7bb","modified":1531227966020},{"_id":"public/css/disqus-proxy.css","hash":"d5086cda8aaae20b8d3f9dd50f0be5ccb717e42a","modified":1531227966020},{"_id":"public/js/Valine.min.js","hash":"6a287a99a772a0ea8f98b133523429c9250cc67f","modified":1531227966020},{"_id":"public/img/favicon.png","hash":"99c7ea94e9346b9b8fe61e8eca515d305f96f349","modified":1531227966020},{"_id":"public/img/logo.png","hash":"99c7ea94e9346b9b8fe61e8eca515d305f96f349","modified":1531227966020},{"_id":"public/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1531227966027},{"_id":"public/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1531227966027},{"_id":"public/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1531227966030},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1531227966072},{"_id":"public/css/material-icons.css","hash":"f6f95fe5190f3c65931847246621fb83754eb00c","modified":1531227966089},{"_id":"public/js/MathJax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1531227966089},{"_id":"public/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1531227966089},{"_id":"public/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1531227966089},{"_id":"public/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1531227966090},{"_id":"public/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1531227966090},{"_id":"public/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1531227966090},{"_id":"public/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1531227966091},{"_id":"public/css/style.min.css","hash":"a9e9b33e1fcf818f08a04b909c86f2460a05f060","modified":1531227966142},{"_id":"public/css/material.min.css","hash":"1a19febb9214ab689b02f5bb8ccb23579e6c1181","modified":1531227966159},{"_id":"public/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1531227966163},{"_id":"public/css/style.css","hash":"95749779bcb6e0466f51b686cf34163eaf90bfa7","modified":1531227966166},{"_id":"public/css/material.css","hash":"068e2b00f686157b6e8b78b9b808112adbedf4de","modified":1531227966168},{"_id":"public/js/js.min.js","hash":"6e3fb908ed653bfbef5d2b9cbadd6c56187f4e1a","modified":1531227966168},{"_id":"public/js/js.js","hash":"d919314cdfe92664462d67738ff9f4aaad0afb8c","modified":1531227966171}],"Category":[{"name":"学习笔记","_id":"cjjfplfiu0004cwp6lgdttqsv"},{"name":"java","_id":"cjjfplfj00009cwp6n79i2lq2"},{"name":"学习笔记","parent":"cjjfplfj00009cwp6n79i2lq2","_id":"cjjfplfj5000fcwp69xub6qcu"},{"name":"java学习笔记","parent":"cjjfplfiu0004cwp6lgdttqsv","_id":"cjjfplfk6000ycwp65kn4m1eq"}],"Data":[{"_id":"links","data":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}}},{"_id":"gallery","data":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}],"Page":[{"title":"关于我","date":"2018-06-24T06:05:06.000Z","layout":"about","_content":"\n### Summary\n* 遇到小而美的 App 完全把持不住，会把玩很久 _(:з」∠)_\n* 喜欢新技术，但也不会盲目的追寻\n* 对于能提升效率的工具会爱不释手\n* 有点强迫症，比如双斜杠注释后面要有空格、xml 的布局文件会对属性进行排序、中英文之间要有空格…\n* 努力为开源社区做点自己的贡献\n\n### Language\n目前我正在使用以下语言：\n* `Python`: 我目前正在学的语言，不会Python都不好意思说自己是程序员\n* `Java`: 毕竟入坑语言\n* `JavaScript`: 前端必学\n\n### Timeline\n* `2015.05` 建立自己的博客网站\n* `2014.12` 接触编程, 自学Java\n* `2014.09` 进入南昌工学院就读网络工程专业\n\n### Contact\n* Github: [szpinc](https://github.com/szpinc)\n* Email: [i@szpinc.org](mailto://i@szpinc.org)\n* Weibo: [@不知名的Coder](https://weibo.com/szpinc)\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2018-06-24 14:05:06\nlayout: about\n---\n\n### Summary\n* 遇到小而美的 App 完全把持不住，会把玩很久 _(:з」∠)_\n* 喜欢新技术，但也不会盲目的追寻\n* 对于能提升效率的工具会爱不释手\n* 有点强迫症，比如双斜杠注释后面要有空格、xml 的布局文件会对属性进行排序、中英文之间要有空格…\n* 努力为开源社区做点自己的贡献\n\n### Language\n目前我正在使用以下语言：\n* `Python`: 我目前正在学的语言，不会Python都不好意思说自己是程序员\n* `Java`: 毕竟入坑语言\n* `JavaScript`: 前端必学\n\n### Timeline\n* `2015.05` 建立自己的博客网站\n* `2014.12` 接触编程, 自学Java\n* `2014.09` 进入南昌工学院就读网络工程专业\n\n### Contact\n* Github: [szpinc](https://github.com/szpinc)\n* Email: [i@szpinc.org](mailto://i@szpinc.org)\n* Weibo: [@不知名的Coder](https://weibo.com/szpinc)\n\n","updated":"2018-07-10T07:59:45.591Z","path":"about/index.html","comments":1,"_id":"cjjfplfiq0001cwp6yz6s26ul","content":"<h3><span id=\"summary\">Summary</span></h3><ul>\n<li>遇到小而美的 App 完全把持不住，会把玩很久 <em>(:з」∠)</em></li>\n<li>喜欢新技术，但也不会盲目的追寻</li>\n<li>对于能提升效率的工具会爱不释手</li>\n<li>有点强迫症，比如双斜杠注释后面要有空格、xml 的布局文件会对属性进行排序、中英文之间要有空格…</li>\n<li>努力为开源社区做点自己的贡献</li>\n</ul>\n<h3><span id=\"language\">Language</span></h3><p>目前我正在使用以下语言：</p>\n<ul>\n<li><code>Python</code>: 我目前正在学的语言，不会Python都不好意思说自己是程序员</li>\n<li><code>Java</code>: 毕竟入坑语言</li>\n<li><code>JavaScript</code>: 前端必学</li>\n</ul>\n<h3><span id=\"timeline\">Timeline</span></h3><ul>\n<li><code>2015.05</code> 建立自己的博客网站</li>\n<li><code>2014.12</code> 接触编程, 自学Java</li>\n<li><code>2014.09</code> 进入南昌工学院就读网络工程专业</li>\n</ul>\n<h3><span id=\"contact\">Contact</span></h3><ul>\n<li>Github: <a href=\"https://github.com/szpinc\" target=\"_blank\" rel=\"noopener\">szpinc</a></li>\n<li>Email: <a href=\"mailto://i@szpinc.org\" target=\"_blank\" rel=\"noopener\">i@szpinc.org</a></li>\n<li>Weibo: <a href=\"https://weibo.com/szpinc\" target=\"_blank\" rel=\"noopener\">@不知名的Coder</a></li>\n</ul>\n","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":"<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><ul>\n<li>遇到小而美的 App 完全把持不住，会把玩很久 <em>(:з」∠)</em></li>\n<li>喜欢新技术，但也不会盲目的追寻</li>\n<li>对于能提升效率的工具会爱不释手</li>\n<li>有点强迫症，比如双斜杠注释后面要有空格、xml 的布局文件会对属性进行排序、中英文之间要有空格…</li>\n<li>努力为开源社区做点自己的贡献</li>\n</ul>\n<h3 id=\"Language\"><a href=\"#Language\" class=\"headerlink\" title=\"Language\"></a>Language</h3><p>目前我正在使用以下语言：</p>\n<ul>\n<li><code>Python</code>: 我目前正在学的语言，不会Python都不好意思说自己是程序员</li>\n<li><code>Java</code>: 毕竟入坑语言</li>\n<li><code>JavaScript</code>: 前端必学</li>\n</ul>\n<h3 id=\"Timeline\"><a href=\"#Timeline\" class=\"headerlink\" title=\"Timeline\"></a>Timeline</h3><ul>\n<li><code>2015.05</code> 建立自己的博客网站</li>\n<li><code>2014.12</code> 接触编程, 自学Java</li>\n<li><code>2014.09</code> 进入南昌工学院就读网络工程专业</li>\n</ul>\n<h3 id=\"Contact\"><a href=\"#Contact\" class=\"headerlink\" title=\"Contact\"></a>Contact</h3><ul>\n<li>Github: <a href=\"https://github.com/szpinc\" target=\"_blank\" rel=\"noopener\">szpinc</a></li>\n<li>Email: <a href=\"mailto://i@szpinc.org\" target=\"_blank\" rel=\"noopener\">i@szpinc.org</a></li>\n<li>Weibo: <a href=\"https://weibo.com/szpinc\" target=\"_blank\" rel=\"noopener\">@不知名的Coder</a></li>\n</ul>\n"},{"title":"图库","date":"2018-06-24T04:42:47.000Z","layout":"gallery","_content":"","source":"gallery/index.md","raw":"---\ntitle: 图库\ndate: 2018-06-24 12:42:47\nlayout: gallery\n---\n","updated":"2018-07-10T07:59:45.591Z","path":"gallery/index.html","comments":1,"_id":"cjjfplfit0003cwp6z3gb205e","content":"","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":""},{"title":"标签云","date":"2018-06-24T04:34:07.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签云\ndate: 2018-06-24 12:34:07\nlayout: tags\n---\n","updated":"2018-07-10T07:59:45.607Z","path":"tags/index.html","comments":1,"_id":"cjjfplfix0007cwp6zgldul29","content":"","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":""},{"title":"友情链接","date":"2018-06-19T14:03:51.000Z","layout":"links","_content":"","source":"links/index.md","raw":"---\ntitle: 友情链接\ndate: 2018-06-19 22:03:51\nlayout: links\n---\n","updated":"2018-07-10T07:59:45.591Z","path":"links/index.html","comments":1,"_id":"cjjfplfiz0008cwp6s1fnbzh4","content":"","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":""},{"title":"时间轴","date":"2018-06-25T02:51:31.000Z","layout":"timeline","_content":"","source":"timeline/index.md","raw":"---\ntitle: 时间轴\ndate: 2018-06-25 10:51:31\nlayout: timeline\n---\n","updated":"2018-07-10T07:59:45.607Z","path":"timeline/index.html","comments":1,"_id":"cjjfplfj0000bcwp6shfpjifq","content":"","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":""}],"Post":[{"title":"Docker容器技术：初学笔记","date":"2017-06-27T12:04:09.000Z","_content":"\n\n好久没来了。艾维瑞巴迪。我胡汉三又回来了！\n![](http://img.mukewang.com/5820943f00011ebf03630199.gif)\n最近在学习Docker容器技术，顺带整理了一下。\n[Docker官网](https://hub.docker.com/)\n[DockerCloud](https://dashboard.daocloud.io/)\n**1.使用docker需要系统root权限，否则提示权限不足**\n![](http://img.mukewang.com/582092d7000197f310320154.png)\n**2.常用的docker命令**\n  1.查看docker信息（version、info）\n``` bash\n# 查看docker版本\ndocker version\n# 显示docker系统的信息\ndocker info\n```\n2.账号以及对image的操作（search、pull、push、images、rmi、history）\n``` bash\n#登录Docker Hub，push时需要登录\ndocker login\n#退出账号\ndocker logout\n#从远程仓库搜索镜像\ndocker search java\n#从远程仓库拉取镜像\ndocker pull imagePath\n#推送本地镜像到远程仓库\ndocker push imagePath\n#查看所有镜像\ndocker images\n#删除镜像(务必先停掉该镜像下的所有容器)\ndocker rmi [options] imaId\n\nroot@yadong-virtual-machine:/home/yadong# docker rmi 527\nError response from daemon: Conflict, cannot delete 527fbbf3458d because the container 52174c817c43 is using it, use -f to force\nError: failed to remove images: [527]\n\n# 显示一个镜像的历史\ndocker history image_name\n```\n\n3.容器操作（run、create、start、stop、restart、kill、rm、ps、）\n``` bash\n#启动一个容器（create-start）\ndocker run -it -p [port] conId conShell\n#创建一个容器\ndocker create (用法同run，只不过create只创建并不会启动)\n#启动/停止/重启容器\ndocker start/stop/restart\n#杀掉一个容器\ndocker kill conId\n#删除容器（删除处于停止状态的容器）\ndocker rm conId\n#在运行的容器中执行命令\ndocker exec\n#列出正在运行容器\ndocker ps [OPTIONS]\n#列出所有容器\ndocker ps -a\n#列出最近创建的5个容器\ndocker ps -n 5\nOPTIONS说明:\n    -a :显示所有的容器，包括未运行的。\n    -f :根据条件过滤显示的内容。\n    --format :指定返回值的模板文件。\n    -l :显示最近创建的容器。\n    -n :列出最近创建的n个容器。\n    --no-trunc :不截断输出。\n    -q :静默模式，只显示容器编号。\n    -s :显示总的文件大小。\n#提交本地容器为新的镜像（保存对容器的修改）\ndocker commit [-m \"xx\"] conId imagePath\n#容器中的进程管理器\ndocker top conId\n#链接容器\ndocker attach conId\n#获取某个容器的日志\ndocker logs [options] conId\nOPTIONS说明：\n    -f : 跟踪日志输出\n    --since :显示某个开始时间的所有日志\n    -t : 显示时间戳\n    --tail :仅列出最新N条容器日志\n    #查看指定容器的端口映射\n    docker port conId\n    #获取容器/镜像的元数据\n    docker inspect conId\n```\n\n```bash\n#-v挂载多个目录\ndocker run -it -v /home/yadong/yadongDir:/yadongTest -v /home/yadong/yadonga:/yadongaa e07 /bin/bash\n```\n\nDocker常用命令关系图\n![](http://img.mukewang.com/582093910001fed218700970.png)\n容器状态图\n![](http://img.mukewang.com/582093ba0001d21411700620.png)\n\n最后推荐一些学习Docker不错的网站：\n\n1. [DockOne.io，最专业的Docker交流平台](http://dockone.io/)\n2. [Docker —— 从入门到实践](http://udn.yyuap.com/doc/docker_practice/index.html)\n3. [菜鸟学习：Docker篇](http://www.runoob.com/docker/docker-architecture.html)\n\n\n","source":"_posts/Docker容器技术：初学笔记.md","raw":"---\ntitle: Docker容器技术：初学笔记\ndate: 2017-06-27 20:04:09\ntags:\n    - Docker\n    - 云计算\n    - 大数据\n\ncategories:\n    - 学习笔记\n---\n\n\n好久没来了。艾维瑞巴迪。我胡汉三又回来了！\n![](http://img.mukewang.com/5820943f00011ebf03630199.gif)\n最近在学习Docker容器技术，顺带整理了一下。\n[Docker官网](https://hub.docker.com/)\n[DockerCloud](https://dashboard.daocloud.io/)\n**1.使用docker需要系统root权限，否则提示权限不足**\n![](http://img.mukewang.com/582092d7000197f310320154.png)\n**2.常用的docker命令**\n  1.查看docker信息（version、info）\n``` bash\n# 查看docker版本\ndocker version\n# 显示docker系统的信息\ndocker info\n```\n2.账号以及对image的操作（search、pull、push、images、rmi、history）\n``` bash\n#登录Docker Hub，push时需要登录\ndocker login\n#退出账号\ndocker logout\n#从远程仓库搜索镜像\ndocker search java\n#从远程仓库拉取镜像\ndocker pull imagePath\n#推送本地镜像到远程仓库\ndocker push imagePath\n#查看所有镜像\ndocker images\n#删除镜像(务必先停掉该镜像下的所有容器)\ndocker rmi [options] imaId\n\nroot@yadong-virtual-machine:/home/yadong# docker rmi 527\nError response from daemon: Conflict, cannot delete 527fbbf3458d because the container 52174c817c43 is using it, use -f to force\nError: failed to remove images: [527]\n\n# 显示一个镜像的历史\ndocker history image_name\n```\n\n3.容器操作（run、create、start、stop、restart、kill、rm、ps、）\n``` bash\n#启动一个容器（create-start）\ndocker run -it -p [port] conId conShell\n#创建一个容器\ndocker create (用法同run，只不过create只创建并不会启动)\n#启动/停止/重启容器\ndocker start/stop/restart\n#杀掉一个容器\ndocker kill conId\n#删除容器（删除处于停止状态的容器）\ndocker rm conId\n#在运行的容器中执行命令\ndocker exec\n#列出正在运行容器\ndocker ps [OPTIONS]\n#列出所有容器\ndocker ps -a\n#列出最近创建的5个容器\ndocker ps -n 5\nOPTIONS说明:\n    -a :显示所有的容器，包括未运行的。\n    -f :根据条件过滤显示的内容。\n    --format :指定返回值的模板文件。\n    -l :显示最近创建的容器。\n    -n :列出最近创建的n个容器。\n    --no-trunc :不截断输出。\n    -q :静默模式，只显示容器编号。\n    -s :显示总的文件大小。\n#提交本地容器为新的镜像（保存对容器的修改）\ndocker commit [-m \"xx\"] conId imagePath\n#容器中的进程管理器\ndocker top conId\n#链接容器\ndocker attach conId\n#获取某个容器的日志\ndocker logs [options] conId\nOPTIONS说明：\n    -f : 跟踪日志输出\n    --since :显示某个开始时间的所有日志\n    -t : 显示时间戳\n    --tail :仅列出最新N条容器日志\n    #查看指定容器的端口映射\n    docker port conId\n    #获取容器/镜像的元数据\n    docker inspect conId\n```\n\n```bash\n#-v挂载多个目录\ndocker run -it -v /home/yadong/yadongDir:/yadongTest -v /home/yadong/yadonga:/yadongaa e07 /bin/bash\n```\n\nDocker常用命令关系图\n![](http://img.mukewang.com/582093910001fed218700970.png)\n容器状态图\n![](http://img.mukewang.com/582093ba0001d21411700620.png)\n\n最后推荐一些学习Docker不错的网站：\n\n1. [DockOne.io，最专业的Docker交流平台](http://dockone.io/)\n2. [Docker —— 从入门到实践](http://udn.yyuap.com/doc/docker_practice/index.html)\n3. [菜鸟学习：Docker篇](http://www.runoob.com/docker/docker-architecture.html)\n\n\n","slug":"Docker容器技术：初学笔记","published":1,"updated":"2018-07-10T07:59:45.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjfplfik0000cwp6z3j9sknb","content":"<p>好久没来了。艾维瑞巴迪。我胡汉三又回来了！<br><img src=\"http://img.mukewang.com/5820943f00011ebf03630199.gif\" alt=\"\"><br>最近在学习Docker容器技术，顺带整理了一下。<br><a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker官网</a><br><a href=\"https://dashboard.daocloud.io/\" target=\"_blank\" rel=\"noopener\">DockerCloud</a><br><strong>1.使用docker需要系统root权限，否则提示权限不足</strong><br><img src=\"http://img.mukewang.com/582092d7000197f310320154.png\" alt=\"\"><br><strong>2.常用的docker命令</strong><br>  1.查看docker信息（version、info）</p>\n<pre><code class=\"bash\"># 查看docker版本\ndocker version\n# 显示docker系统的信息\ndocker info\n</code></pre>\n<p>2.账号以及对image的操作（search、pull、push、images、rmi、history）</p>\n<pre><code class=\"bash\">#登录Docker Hub，push时需要登录\ndocker login\n#退出账号\ndocker logout\n#从远程仓库搜索镜像\ndocker search java\n#从远程仓库拉取镜像\ndocker pull imagePath\n#推送本地镜像到远程仓库\ndocker push imagePath\n#查看所有镜像\ndocker images\n#删除镜像(务必先停掉该镜像下的所有容器)\ndocker rmi [options] imaId\n\nroot@yadong-virtual-machine:/home/yadong# docker rmi 527\nError response from daemon: Conflict, cannot delete 527fbbf3458d because the container 52174c817c43 is using it, use -f to force\nError: failed to remove images: [527]\n\n# 显示一个镜像的历史\ndocker history image_name\n</code></pre>\n<p>3.容器操作（run、create、start、stop、restart、kill、rm、ps、）</p>\n<pre><code class=\"bash\">#启动一个容器（create-start）\ndocker run -it -p [port] conId conShell\n#创建一个容器\ndocker create (用法同run，只不过create只创建并不会启动)\n#启动/停止/重启容器\ndocker start/stop/restart\n#杀掉一个容器\ndocker kill conId\n#删除容器（删除处于停止状态的容器）\ndocker rm conId\n#在运行的容器中执行命令\ndocker exec\n#列出正在运行容器\ndocker ps [OPTIONS]\n#列出所有容器\ndocker ps -a\n#列出最近创建的5个容器\ndocker ps -n 5\nOPTIONS说明:\n    -a :显示所有的容器，包括未运行的。\n    -f :根据条件过滤显示的内容。\n    --format :指定返回值的模板文件。\n    -l :显示最近创建的容器。\n    -n :列出最近创建的n个容器。\n    --no-trunc :不截断输出。\n    -q :静默模式，只显示容器编号。\n    -s :显示总的文件大小。\n#提交本地容器为新的镜像（保存对容器的修改）\ndocker commit [-m &quot;xx&quot;] conId imagePath\n#容器中的进程管理器\ndocker top conId\n#链接容器\ndocker attach conId\n#获取某个容器的日志\ndocker logs [options] conId\nOPTIONS说明：\n    -f : 跟踪日志输出\n    --since :显示某个开始时间的所有日志\n    -t : 显示时间戳\n    --tail :仅列出最新N条容器日志\n    #查看指定容器的端口映射\n    docker port conId\n    #获取容器/镜像的元数据\n    docker inspect conId\n</code></pre>\n<pre><code class=\"bash\">#-v挂载多个目录\ndocker run -it -v /home/yadong/yadongDir:/yadongTest -v /home/yadong/yadonga:/yadongaa e07 /bin/bash\n</code></pre>\n<p>Docker常用命令关系图<br><img src=\"http://img.mukewang.com/582093910001fed218700970.png\" alt=\"\"><br>容器状态图<br><img src=\"http://img.mukewang.com/582093ba0001d21411700620.png\" alt=\"\"></p>\n<p>最后推荐一些学习Docker不错的网站：</p>\n<ol>\n<li><a href=\"http://dockone.io/\" target=\"_blank\" rel=\"noopener\">DockOne.io，最专业的Docker交流平台</a></li>\n<li><a href=\"http://udn.yyuap.com/doc/docker_practice/index.html\" target=\"_blank\" rel=\"noopener\">Docker —— 从入门到实践</a></li>\n<li><a href=\"http://www.runoob.com/docker/docker-architecture.html\" target=\"_blank\" rel=\"noopener\">菜鸟学习：Docker篇</a></li>\n</ol>\n","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":"<p>好久没来了。艾维瑞巴迪。我胡汉三又回来了！<br><img src=\"http://img.mukewang.com/5820943f00011ebf03630199.gif\" alt=\"\"><br>最近在学习Docker容器技术，顺带整理了一下。<br><a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker官网</a><br><a href=\"https://dashboard.daocloud.io/\" target=\"_blank\" rel=\"noopener\">DockerCloud</a><br><strong>1.使用docker需要系统root权限，否则提示权限不足</strong><br><img src=\"http://img.mukewang.com/582092d7000197f310320154.png\" alt=\"\"><br><strong>2.常用的docker命令</strong><br>  1.查看docker信息（version、info）</p>\n<pre><code class=\"bash\"># 查看docker版本\ndocker version\n# 显示docker系统的信息\ndocker info\n</code></pre>\n<p>2.账号以及对image的操作（search、pull、push、images、rmi、history）</p>\n<pre><code class=\"bash\">#登录Docker Hub，push时需要登录\ndocker login\n#退出账号\ndocker logout\n#从远程仓库搜索镜像\ndocker search java\n#从远程仓库拉取镜像\ndocker pull imagePath\n#推送本地镜像到远程仓库\ndocker push imagePath\n#查看所有镜像\ndocker images\n#删除镜像(务必先停掉该镜像下的所有容器)\ndocker rmi [options] imaId\n\nroot@yadong-virtual-machine:/home/yadong# docker rmi 527\nError response from daemon: Conflict, cannot delete 527fbbf3458d because the container 52174c817c43 is using it, use -f to force\nError: failed to remove images: [527]\n\n# 显示一个镜像的历史\ndocker history image_name\n</code></pre>\n<p>3.容器操作（run、create、start、stop、restart、kill、rm、ps、）</p>\n<pre><code class=\"bash\">#启动一个容器（create-start）\ndocker run -it -p [port] conId conShell\n#创建一个容器\ndocker create (用法同run，只不过create只创建并不会启动)\n#启动/停止/重启容器\ndocker start/stop/restart\n#杀掉一个容器\ndocker kill conId\n#删除容器（删除处于停止状态的容器）\ndocker rm conId\n#在运行的容器中执行命令\ndocker exec\n#列出正在运行容器\ndocker ps [OPTIONS]\n#列出所有容器\ndocker ps -a\n#列出最近创建的5个容器\ndocker ps -n 5\nOPTIONS说明:\n    -a :显示所有的容器，包括未运行的。\n    -f :根据条件过滤显示的内容。\n    --format :指定返回值的模板文件。\n    -l :显示最近创建的容器。\n    -n :列出最近创建的n个容器。\n    --no-trunc :不截断输出。\n    -q :静默模式，只显示容器编号。\n    -s :显示总的文件大小。\n#提交本地容器为新的镜像（保存对容器的修改）\ndocker commit [-m &quot;xx&quot;] conId imagePath\n#容器中的进程管理器\ndocker top conId\n#链接容器\ndocker attach conId\n#获取某个容器的日志\ndocker logs [options] conId\nOPTIONS说明：\n    -f : 跟踪日志输出\n    --since :显示某个开始时间的所有日志\n    -t : 显示时间戳\n    --tail :仅列出最新N条容器日志\n    #查看指定容器的端口映射\n    docker port conId\n    #获取容器/镜像的元数据\n    docker inspect conId\n</code></pre>\n<pre><code class=\"bash\">#-v挂载多个目录\ndocker run -it -v /home/yadong/yadongDir:/yadongTest -v /home/yadong/yadonga:/yadongaa e07 /bin/bash\n</code></pre>\n<p>Docker常用命令关系图<br><img src=\"http://img.mukewang.com/582093910001fed218700970.png\" alt=\"\"><br>容器状态图<br><img src=\"http://img.mukewang.com/582093ba0001d21411700620.png\" alt=\"\"></p>\n<p>最后推荐一些学习Docker不错的网站：</p>\n<ol>\n<li><a href=\"http://dockone.io/\" target=\"_blank\" rel=\"noopener\">DockOne.io，最专业的Docker交流平台</a></li>\n<li><a href=\"http://udn.yyuap.com/doc/docker_practice/index.html\" target=\"_blank\" rel=\"noopener\">Docker —— 从入门到实践</a></li>\n<li><a href=\"http://www.runoob.com/docker/docker-architecture.html\" target=\"_blank\" rel=\"noopener\">菜鸟学习：Docker篇</a></li>\n</ol>\n"},{"title":"HashMap中傻傻分不清楚的那些概念","date":"2017-06-28T12:13:58.000Z","_content":"\n> 很多人在通过阅读源码的方式学习Java，这是个很好的方式。而JDK的源码自然是首选。在JDK的众多类中，我觉得HashMap及其相关的类是设计的比较好的。很多人读过HashMap的代码，不知道你们有没有和我一样，觉得HashMap中关于容量相关的参数定义的太多了，傻傻分不清楚。\n\n> 其实，这篇文章介绍的内容比较简单，只要认真的看看HashMap的原理还是可以理解的，单独写一篇文章的原因是因为我后面还有几篇关于HashMap源码分析的文章，这些概念不熟悉的话阅读后面的文章会很吃力。\n\n## HashMap中重要的成员变量\n\n先来看一下，HashMap中都定义了哪些成员变量。\n\n![1528879455718941](https://img.szpinc.org/2018-06-27-1528879455718941.jpg)\n\n上面是一张HashMap中主要的成员变量的图，其中有一个是我们本文主要关注的： `size`、`loadFactor`、`threshold`、`DEFAULT_LOAD_FACTOR`和`DEFAULT_INITIAL_CAPACITY`。\n\n我们先来简单解释一下这些参数的含义，然后再分析他们的作用。\n\nHashMap类中有以下主要成员变量：\n* transient int size;\n    * 记录了Map中KV对的个数\n* loadFactor\n    * 装载印子，用来衡量HashMap满的程度。loadFactor的默认值为0.75f（`static final float DEFAULT_LOAD_FACTOR = 0.75f`;）。\n* int threshold;\n    * 临界值，当实际KV个数超过threshold时，HashMap会将容量扩容，threshold＝容量*加载因子\n* 除了以上这些重要成员变量外，HashMap中还有一个和他们紧密相关的概念：capacity\n    * 容量，如果不指定，默认容量是16(`static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;`)\n\n可能看完了你还是有点蒙，size和capacity之间有啥关系？为啥要定义这两个变量。loadFactor和threshold又是干啥的？\n\n## size 和 capacity\n\nHashMap中的size和capacity之间的区别其实解释起来也挺简单的。我们知道，HashMap就像一个“桶”，那么capacity就是这个桶“当前”最多可以装多少元素，而size表示这个桶已经装了多少元素。来看下以下代码：\n``` java\nMap<String, String> map = new HashMap<String, String>();\nmap.put(\"hollis\", \"hollischuang\");\n\nClass<?> mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(\"size\");\nsize.setAccessible(true);\nSystem.out.println(\"size : \" + size.get(map));\n```\n我们定义了一个新的HashMap，并想其中put了一个元素，然后通过反射的方式打印capacity和size。输出结果为：**capacity : 16、size : 1**\n\n默认情况下，一个HashMap的容量（capacity）是16，设计成16的好处我在《全网把Map中的hash()分析的最透彻的文章，别无二家。》中也简单介绍过，主要是可以使用按位与替代取模来提升hash的效率。\n\n为什么我刚刚说capacity就是这个桶“当前”最多可以装多少元素呢？当前怎么理解呢。其实，HashMap是具有扩容机制的。在一个HashMap第一次初始化的时候，默认情况下他的容量是16，当达到扩容条件的时候，就需要进行扩容了，会从16扩容成32。\n\n我们知道，HashMap的重载的构造函数中，有一个是支持传入initialCapacity的，那么我们尝试着设置一下，看结果如何。\n``` java\nMap<String, String> map = new HashMap<String, String>(1);\nmap.put(\"hahaha\", \"hollischuang\");\n\nClass<?> mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n\nMap<String, String> map = new HashMap<String, String>(7);\nmap.put(\"hahaha\", \"hollischuang\");\n\nClass<?> mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n\n\nMap<String, String> map = new HashMap<String, String>(9);\nmap.put(\"hahaha\", \"hollischuang\");\n\nClass<?> mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n```\n分别执行以上3段代码，分别输出：**capacity : 2**、**capacity : 8**、**capacity : 16**。\n\n> 也就是说，默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(1->2、7->8、9->16)\n\n## loadFactor 和 threshold\n\n前面我们提到过，HashMap有扩容机制，就是当达到扩容条件时会进行扩容，从16扩容到32、64、128...\n\n那么，这个扩容条件指的是什么呢？\n\n其实，HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。\n\n在HashMap中，threshold = loadFactor * capacity。\n\nloadFactor是装载因子，表示HashMap满的程度，默认值为0.75f，设置成0.75有一个好处，那就是0.75正好是3/4，而capacity又是2的幂。所以，两个数的乘积都是整数（capacity为2也同样）。\n\n对于一个默认的HashMap来说，默认情况下，当其size大于12(16*0.75)时就会触发扩容。\n\n验证代码如下：\n``` java\nMap<String, String> map = new HashMap<>();\nmap.put(\"hollis1\", \"hollischuang\");\nmap.put(\"hollis2\", \"hollischuang\");\nmap.put(\"hollis3\", \"hollischuang\");\nmap.put(\"hollis4\", \"hollischuang\");\nmap.put(\"hollis5\", \"hollischuang\");\nmap.put(\"hollis6\", \"hollischuang\");\nmap.put(\"hollis7\", \"hollischuang\");\nmap.put(\"hollis8\", \"hollischuang\");\nmap.put(\"hollis9\", \"hollischuang\");\nmap.put(\"hollis10\", \"hollischuang\");\nmap.put(\"hollis11\", \"hollischuang\");\nmap.put(\"hollis12\", \"hollischuang\");\nClass<?> mapType = map.getClass();\n\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(\"size\");\nsize.setAccessible(true);\nSystem.out.println(\"size : \" + size.get(map));\n\nField threshold = mapType.getDeclaredField(\"threshold\");\nthreshold.setAccessible(true);\nSystem.out.println(\"threshold : \" + threshold.get(map));\n\nField loadFactor = mapType.getDeclaredField(\"loadFactor\");\nloadFactor.setAccessible(true);\nSystem.out.println(\"loadFactor : \" + loadFactor.get(map));\n\nmap.put(\"hollis13\", \"hollischuang\");\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(\"size\");\nsize.setAccessible(true);\nSystem.out.println(\"size : \" + size.get(map));\n\nField threshold = mapType.getDeclaredField(\"threshold\");\nthreshold.setAccessible(true);\nSystem.out.println(\"threshold : \" + threshold.get(map));\n\nField loadFactor = mapType.getDeclaredField(\"loadFactor\");\nloadFactor.setAccessible(true);\nSystem.out.println(\"loadFactor : \" + loadFactor.get(map));\n```\n输出结果：\n``` java\ncapacity : 16\nsize : 12\nthreshold : 12\nloadFactor : 0.75\n\ncapacity : 32\nsize : 13\nthreshold : 24\nloadFactor : 0.75\n```\n当HashMap中的元素个数达到13的时候，capacity就从16扩容到32了。\n\nHashMap中还提供了一个支持传入initialCapacity,loadFactor两个参数的方法，来初始化容量和装载因子。不过，一般不建议修改loadFactor的值。\n\n## 总结\nHashMap中size表示当前共有多少个KV对，capacity表示当前HashMap的容量是多少，默认值是16，每次扩容都是成倍的。loadFactor是装载因子，当Map中元素个数超过`loadFactor* capacity`的值时，会触发扩容。`loadFactor* capacity`可以用threshold表示。\n\n","source":"_posts/HashMap中傻傻分不清楚的那些概念.md","raw":"---\ntitle: HashMap中傻傻分不清楚的那些概念\ndate: 2017-06-28 20:13:58\ntags:\n    - java\ncategories:\n    - java\n    - 学习笔记\n---\n\n> 很多人在通过阅读源码的方式学习Java，这是个很好的方式。而JDK的源码自然是首选。在JDK的众多类中，我觉得HashMap及其相关的类是设计的比较好的。很多人读过HashMap的代码，不知道你们有没有和我一样，觉得HashMap中关于容量相关的参数定义的太多了，傻傻分不清楚。\n\n> 其实，这篇文章介绍的内容比较简单，只要认真的看看HashMap的原理还是可以理解的，单独写一篇文章的原因是因为我后面还有几篇关于HashMap源码分析的文章，这些概念不熟悉的话阅读后面的文章会很吃力。\n\n## HashMap中重要的成员变量\n\n先来看一下，HashMap中都定义了哪些成员变量。\n\n![1528879455718941](https://img.szpinc.org/2018-06-27-1528879455718941.jpg)\n\n上面是一张HashMap中主要的成员变量的图，其中有一个是我们本文主要关注的： `size`、`loadFactor`、`threshold`、`DEFAULT_LOAD_FACTOR`和`DEFAULT_INITIAL_CAPACITY`。\n\n我们先来简单解释一下这些参数的含义，然后再分析他们的作用。\n\nHashMap类中有以下主要成员变量：\n* transient int size;\n    * 记录了Map中KV对的个数\n* loadFactor\n    * 装载印子，用来衡量HashMap满的程度。loadFactor的默认值为0.75f（`static final float DEFAULT_LOAD_FACTOR = 0.75f`;）。\n* int threshold;\n    * 临界值，当实际KV个数超过threshold时，HashMap会将容量扩容，threshold＝容量*加载因子\n* 除了以上这些重要成员变量外，HashMap中还有一个和他们紧密相关的概念：capacity\n    * 容量，如果不指定，默认容量是16(`static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;`)\n\n可能看完了你还是有点蒙，size和capacity之间有啥关系？为啥要定义这两个变量。loadFactor和threshold又是干啥的？\n\n## size 和 capacity\n\nHashMap中的size和capacity之间的区别其实解释起来也挺简单的。我们知道，HashMap就像一个“桶”，那么capacity就是这个桶“当前”最多可以装多少元素，而size表示这个桶已经装了多少元素。来看下以下代码：\n``` java\nMap<String, String> map = new HashMap<String, String>();\nmap.put(\"hollis\", \"hollischuang\");\n\nClass<?> mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(\"size\");\nsize.setAccessible(true);\nSystem.out.println(\"size : \" + size.get(map));\n```\n我们定义了一个新的HashMap，并想其中put了一个元素，然后通过反射的方式打印capacity和size。输出结果为：**capacity : 16、size : 1**\n\n默认情况下，一个HashMap的容量（capacity）是16，设计成16的好处我在《全网把Map中的hash()分析的最透彻的文章，别无二家。》中也简单介绍过，主要是可以使用按位与替代取模来提升hash的效率。\n\n为什么我刚刚说capacity就是这个桶“当前”最多可以装多少元素呢？当前怎么理解呢。其实，HashMap是具有扩容机制的。在一个HashMap第一次初始化的时候，默认情况下他的容量是16，当达到扩容条件的时候，就需要进行扩容了，会从16扩容成32。\n\n我们知道，HashMap的重载的构造函数中，有一个是支持传入initialCapacity的，那么我们尝试着设置一下，看结果如何。\n``` java\nMap<String, String> map = new HashMap<String, String>(1);\nmap.put(\"hahaha\", \"hollischuang\");\n\nClass<?> mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n\nMap<String, String> map = new HashMap<String, String>(7);\nmap.put(\"hahaha\", \"hollischuang\");\n\nClass<?> mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n\n\nMap<String, String> map = new HashMap<String, String>(9);\nmap.put(\"hahaha\", \"hollischuang\");\n\nClass<?> mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n```\n分别执行以上3段代码，分别输出：**capacity : 2**、**capacity : 8**、**capacity : 16**。\n\n> 也就是说，默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(1->2、7->8、9->16)\n\n## loadFactor 和 threshold\n\n前面我们提到过，HashMap有扩容机制，就是当达到扩容条件时会进行扩容，从16扩容到32、64、128...\n\n那么，这个扩容条件指的是什么呢？\n\n其实，HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。\n\n在HashMap中，threshold = loadFactor * capacity。\n\nloadFactor是装载因子，表示HashMap满的程度，默认值为0.75f，设置成0.75有一个好处，那就是0.75正好是3/4，而capacity又是2的幂。所以，两个数的乘积都是整数（capacity为2也同样）。\n\n对于一个默认的HashMap来说，默认情况下，当其size大于12(16*0.75)时就会触发扩容。\n\n验证代码如下：\n``` java\nMap<String, String> map = new HashMap<>();\nmap.put(\"hollis1\", \"hollischuang\");\nmap.put(\"hollis2\", \"hollischuang\");\nmap.put(\"hollis3\", \"hollischuang\");\nmap.put(\"hollis4\", \"hollischuang\");\nmap.put(\"hollis5\", \"hollischuang\");\nmap.put(\"hollis6\", \"hollischuang\");\nmap.put(\"hollis7\", \"hollischuang\");\nmap.put(\"hollis8\", \"hollischuang\");\nmap.put(\"hollis9\", \"hollischuang\");\nmap.put(\"hollis10\", \"hollischuang\");\nmap.put(\"hollis11\", \"hollischuang\");\nmap.put(\"hollis12\", \"hollischuang\");\nClass<?> mapType = map.getClass();\n\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(\"size\");\nsize.setAccessible(true);\nSystem.out.println(\"size : \" + size.get(map));\n\nField threshold = mapType.getDeclaredField(\"threshold\");\nthreshold.setAccessible(true);\nSystem.out.println(\"threshold : \" + threshold.get(map));\n\nField loadFactor = mapType.getDeclaredField(\"loadFactor\");\nloadFactor.setAccessible(true);\nSystem.out.println(\"loadFactor : \" + loadFactor.get(map));\n\nmap.put(\"hollis13\", \"hollischuang\");\nMethod capacity = mapType.getDeclaredMethod(\"capacity\");\ncapacity.setAccessible(true);\nSystem.out.println(\"capacity : \" + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(\"size\");\nsize.setAccessible(true);\nSystem.out.println(\"size : \" + size.get(map));\n\nField threshold = mapType.getDeclaredField(\"threshold\");\nthreshold.setAccessible(true);\nSystem.out.println(\"threshold : \" + threshold.get(map));\n\nField loadFactor = mapType.getDeclaredField(\"loadFactor\");\nloadFactor.setAccessible(true);\nSystem.out.println(\"loadFactor : \" + loadFactor.get(map));\n```\n输出结果：\n``` java\ncapacity : 16\nsize : 12\nthreshold : 12\nloadFactor : 0.75\n\ncapacity : 32\nsize : 13\nthreshold : 24\nloadFactor : 0.75\n```\n当HashMap中的元素个数达到13的时候，capacity就从16扩容到32了。\n\nHashMap中还提供了一个支持传入initialCapacity,loadFactor两个参数的方法，来初始化容量和装载因子。不过，一般不建议修改loadFactor的值。\n\n## 总结\nHashMap中size表示当前共有多少个KV对，capacity表示当前HashMap的容量是多少，默认值是16，每次扩容都是成倍的。loadFactor是装载因子，当Map中元素个数超过`loadFactor* capacity`的值时，会触发扩容。`loadFactor* capacity`可以用threshold表示。\n\n","slug":"HashMap中傻傻分不清楚的那些概念","published":1,"updated":"2018-07-10T07:59:45.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjfplfir0002cwp6i2elnpx9","content":"<blockquote>\n<p>很多人在通过阅读源码的方式学习Java，这是个很好的方式。而JDK的源码自然是首选。在JDK的众多类中，我觉得HashMap及其相关的类是设计的比较好的。很多人读过HashMap的代码，不知道你们有没有和我一样，觉得HashMap中关于容量相关的参数定义的太多了，傻傻分不清楚。</p>\n</blockquote>\n<blockquote>\n<p>其实，这篇文章介绍的内容比较简单，只要认真的看看HashMap的原理还是可以理解的，单独写一篇文章的原因是因为我后面还有几篇关于HashMap源码分析的文章，这些概念不熟悉的话阅读后面的文章会很吃力。</p>\n</blockquote>\n<h2><span id=\"hashmap中重要的成员变量\">HashMap中重要的成员变量</span></h2><p>先来看一下，HashMap中都定义了哪些成员变量。</p>\n<p><img src=\"https://img.szpinc.org/2018-06-27-1528879455718941.jpg\" alt=\"1528879455718941\"></p>\n<p>上面是一张HashMap中主要的成员变量的图，其中有一个是我们本文主要关注的： <code>size</code>、<code>loadFactor</code>、<code>threshold</code>、<code>DEFAULT_LOAD_FACTOR</code>和<code>DEFAULT_INITIAL_CAPACITY</code>。</p>\n<p>我们先来简单解释一下这些参数的含义，然后再分析他们的作用。</p>\n<p>HashMap类中有以下主要成员变量：</p>\n<ul>\n<li>transient int size;<ul>\n<li>记录了Map中KV对的个数</li>\n</ul>\n</li>\n<li>loadFactor<ul>\n<li>装载印子，用来衡量HashMap满的程度。loadFactor的默认值为0.75f（<code>static final float DEFAULT_LOAD_FACTOR = 0.75f</code>;）。</li>\n</ul>\n</li>\n<li>int threshold;<ul>\n<li>临界值，当实际KV个数超过threshold时，HashMap会将容量扩容，threshold＝容量*加载因子</li>\n</ul>\n</li>\n<li>除了以上这些重要成员变量外，HashMap中还有一个和他们紧密相关的概念：capacity<ul>\n<li>容量，如果不指定，默认容量是16(<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</code>)</li>\n</ul>\n</li>\n</ul>\n<p>可能看完了你还是有点蒙，size和capacity之间有啥关系？为啥要定义这两个变量。loadFactor和threshold又是干啥的？</p>\n<h2><span id=\"size-和-capacity\">size 和 capacity</span></h2><p>HashMap中的size和capacity之间的区别其实解释起来也挺简单的。我们知道，HashMap就像一个“桶”，那么capacity就是这个桶“当前”最多可以装多少元素，而size表示这个桶已经装了多少元素。来看下以下代码：</p>\n<pre><code class=\"java\">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\nmap.put(&quot;hollis&quot;, &quot;hollischuang&quot;);\n\nClass&lt;?&gt; mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(&quot;size&quot;);\nsize.setAccessible(true);\nSystem.out.println(&quot;size : &quot; + size.get(map));\n</code></pre>\n<p>我们定义了一个新的HashMap，并想其中put了一个元素，然后通过反射的方式打印capacity和size。输出结果为：<strong>capacity : 16、size : 1</strong></p>\n<p>默认情况下，一个HashMap的容量（capacity）是16，设计成16的好处我在《全网把Map中的hash()分析的最透彻的文章，别无二家。》中也简单介绍过，主要是可以使用按位与替代取模来提升hash的效率。</p>\n<p>为什么我刚刚说capacity就是这个桶“当前”最多可以装多少元素呢？当前怎么理解呢。其实，HashMap是具有扩容机制的。在一个HashMap第一次初始化的时候，默认情况下他的容量是16，当达到扩容条件的时候，就需要进行扩容了，会从16扩容成32。</p>\n<p>我们知道，HashMap的重载的构造函数中，有一个是支持传入initialCapacity的，那么我们尝试着设置一下，看结果如何。</p>\n<pre><code class=\"java\">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(1);\nmap.put(&quot;hahaha&quot;, &quot;hollischuang&quot;);\n\nClass&lt;?&gt; mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n\nMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(7);\nmap.put(&quot;hahaha&quot;, &quot;hollischuang&quot;);\n\nClass&lt;?&gt; mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n\n\nMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(9);\nmap.put(&quot;hahaha&quot;, &quot;hollischuang&quot;);\n\nClass&lt;?&gt; mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n</code></pre>\n<p>分别执行以上3段代码，分别输出：<strong>capacity : 2</strong>、<strong>capacity : 8</strong>、<strong>capacity : 16</strong>。</p>\n<blockquote>\n<p>也就是说，默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(1-&gt;2、7-&gt;8、9-&gt;16)</p>\n</blockquote>\n<h2><span id=\"loadfactor-和-threshold\">loadFactor 和 threshold</span></h2><p>前面我们提到过，HashMap有扩容机制，就是当达到扩容条件时会进行扩容，从16扩容到32、64、128…</p>\n<p>那么，这个扩容条件指的是什么呢？</p>\n<p>其实，HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。</p>\n<p>在HashMap中，threshold = loadFactor * capacity。</p>\n<p>loadFactor是装载因子，表示HashMap满的程度，默认值为0.75f，设置成0.75有一个好处，那就是0.75正好是3/4，而capacity又是2的幂。所以，两个数的乘积都是整数（capacity为2也同样）。</p>\n<p>对于一个默认的HashMap来说，默认情况下，当其size大于12(16*0.75)时就会触发扩容。</p>\n<p>验证代码如下：</p>\n<pre><code class=\"java\">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();\nmap.put(&quot;hollis1&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis2&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis3&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis4&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis5&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis6&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis7&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis8&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis9&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis10&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis11&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis12&quot;, &quot;hollischuang&quot;);\nClass&lt;?&gt; mapType = map.getClass();\n\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(&quot;size&quot;);\nsize.setAccessible(true);\nSystem.out.println(&quot;size : &quot; + size.get(map));\n\nField threshold = mapType.getDeclaredField(&quot;threshold&quot;);\nthreshold.setAccessible(true);\nSystem.out.println(&quot;threshold : &quot; + threshold.get(map));\n\nField loadFactor = mapType.getDeclaredField(&quot;loadFactor&quot;);\nloadFactor.setAccessible(true);\nSystem.out.println(&quot;loadFactor : &quot; + loadFactor.get(map));\n\nmap.put(&quot;hollis13&quot;, &quot;hollischuang&quot;);\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(&quot;size&quot;);\nsize.setAccessible(true);\nSystem.out.println(&quot;size : &quot; + size.get(map));\n\nField threshold = mapType.getDeclaredField(&quot;threshold&quot;);\nthreshold.setAccessible(true);\nSystem.out.println(&quot;threshold : &quot; + threshold.get(map));\n\nField loadFactor = mapType.getDeclaredField(&quot;loadFactor&quot;);\nloadFactor.setAccessible(true);\nSystem.out.println(&quot;loadFactor : &quot; + loadFactor.get(map));\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"java\">capacity : 16\nsize : 12\nthreshold : 12\nloadFactor : 0.75\n\ncapacity : 32\nsize : 13\nthreshold : 24\nloadFactor : 0.75\n</code></pre>\n<p>当HashMap中的元素个数达到13的时候，capacity就从16扩容到32了。</p>\n<p>HashMap中还提供了一个支持传入initialCapacity,loadFactor两个参数的方法，来初始化容量和装载因子。不过，一般不建议修改loadFactor的值。</p>\n<h2><span id=\"总结\">总结</span></h2><p>HashMap中size表示当前共有多少个KV对，capacity表示当前HashMap的容量是多少，默认值是16，每次扩容都是成倍的。loadFactor是装载因子，当Map中元素个数超过<code>loadFactor* capacity</code>的值时，会触发扩容。<code>loadFactor* capacity</code>可以用threshold表示。</p>\n","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":"<blockquote>\n<p>很多人在通过阅读源码的方式学习Java，这是个很好的方式。而JDK的源码自然是首选。在JDK的众多类中，我觉得HashMap及其相关的类是设计的比较好的。很多人读过HashMap的代码，不知道你们有没有和我一样，觉得HashMap中关于容量相关的参数定义的太多了，傻傻分不清楚。</p>\n</blockquote>\n<blockquote>\n<p>其实，这篇文章介绍的内容比较简单，只要认真的看看HashMap的原理还是可以理解的，单独写一篇文章的原因是因为我后面还有几篇关于HashMap源码分析的文章，这些概念不熟悉的话阅读后面的文章会很吃力。</p>\n</blockquote>\n<h2 id=\"HashMap中重要的成员变量\"><a href=\"#HashMap中重要的成员变量\" class=\"headerlink\" title=\"HashMap中重要的成员变量\"></a>HashMap中重要的成员变量</h2><p>先来看一下，HashMap中都定义了哪些成员变量。</p>\n<p><img src=\"https://img.szpinc.org/2018-06-27-1528879455718941.jpg\" alt=\"1528879455718941\"></p>\n<p>上面是一张HashMap中主要的成员变量的图，其中有一个是我们本文主要关注的： <code>size</code>、<code>loadFactor</code>、<code>threshold</code>、<code>DEFAULT_LOAD_FACTOR</code>和<code>DEFAULT_INITIAL_CAPACITY</code>。</p>\n<p>我们先来简单解释一下这些参数的含义，然后再分析他们的作用。</p>\n<p>HashMap类中有以下主要成员变量：</p>\n<ul>\n<li>transient int size;<ul>\n<li>记录了Map中KV对的个数</li>\n</ul>\n</li>\n<li>loadFactor<ul>\n<li>装载印子，用来衡量HashMap满的程度。loadFactor的默认值为0.75f（<code>static final float DEFAULT_LOAD_FACTOR = 0.75f</code>;）。</li>\n</ul>\n</li>\n<li>int threshold;<ul>\n<li>临界值，当实际KV个数超过threshold时，HashMap会将容量扩容，threshold＝容量*加载因子</li>\n</ul>\n</li>\n<li>除了以上这些重要成员变量外，HashMap中还有一个和他们紧密相关的概念：capacity<ul>\n<li>容量，如果不指定，默认容量是16(<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</code>)</li>\n</ul>\n</li>\n</ul>\n<p>可能看完了你还是有点蒙，size和capacity之间有啥关系？为啥要定义这两个变量。loadFactor和threshold又是干啥的？</p>\n<h2 id=\"size-和-capacity\"><a href=\"#size-和-capacity\" class=\"headerlink\" title=\"size 和 capacity\"></a>size 和 capacity</h2><p>HashMap中的size和capacity之间的区别其实解释起来也挺简单的。我们知道，HashMap就像一个“桶”，那么capacity就是这个桶“当前”最多可以装多少元素，而size表示这个桶已经装了多少元素。来看下以下代码：</p>\n<pre><code class=\"java\">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\nmap.put(&quot;hollis&quot;, &quot;hollischuang&quot;);\n\nClass&lt;?&gt; mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(&quot;size&quot;);\nsize.setAccessible(true);\nSystem.out.println(&quot;size : &quot; + size.get(map));\n</code></pre>\n<p>我们定义了一个新的HashMap，并想其中put了一个元素，然后通过反射的方式打印capacity和size。输出结果为：<strong>capacity : 16、size : 1</strong></p>\n<p>默认情况下，一个HashMap的容量（capacity）是16，设计成16的好处我在《全网把Map中的hash()分析的最透彻的文章，别无二家。》中也简单介绍过，主要是可以使用按位与替代取模来提升hash的效率。</p>\n<p>为什么我刚刚说capacity就是这个桶“当前”最多可以装多少元素呢？当前怎么理解呢。其实，HashMap是具有扩容机制的。在一个HashMap第一次初始化的时候，默认情况下他的容量是16，当达到扩容条件的时候，就需要进行扩容了，会从16扩容成32。</p>\n<p>我们知道，HashMap的重载的构造函数中，有一个是支持传入initialCapacity的，那么我们尝试着设置一下，看结果如何。</p>\n<pre><code class=\"java\">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(1);\nmap.put(&quot;hahaha&quot;, &quot;hollischuang&quot;);\n\nClass&lt;?&gt; mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n\nMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(7);\nmap.put(&quot;hahaha&quot;, &quot;hollischuang&quot;);\n\nClass&lt;?&gt; mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n\n\nMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(9);\nmap.put(&quot;hahaha&quot;, &quot;hollischuang&quot;);\n\nClass&lt;?&gt; mapType = map.getClass();\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n</code></pre>\n<p>分别执行以上3段代码，分别输出：<strong>capacity : 2</strong>、<strong>capacity : 8</strong>、<strong>capacity : 16</strong>。</p>\n<blockquote>\n<p>也就是说，默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(1-&gt;2、7-&gt;8、9-&gt;16)</p>\n</blockquote>\n<h2 id=\"loadFactor-和-threshold\"><a href=\"#loadFactor-和-threshold\" class=\"headerlink\" title=\"loadFactor 和 threshold\"></a>loadFactor 和 threshold</h2><p>前面我们提到过，HashMap有扩容机制，就是当达到扩容条件时会进行扩容，从16扩容到32、64、128…</p>\n<p>那么，这个扩容条件指的是什么呢？</p>\n<p>其实，HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。</p>\n<p>在HashMap中，threshold = loadFactor * capacity。</p>\n<p>loadFactor是装载因子，表示HashMap满的程度，默认值为0.75f，设置成0.75有一个好处，那就是0.75正好是3/4，而capacity又是2的幂。所以，两个数的乘积都是整数（capacity为2也同样）。</p>\n<p>对于一个默认的HashMap来说，默认情况下，当其size大于12(16*0.75)时就会触发扩容。</p>\n<p>验证代码如下：</p>\n<pre><code class=\"java\">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();\nmap.put(&quot;hollis1&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis2&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis3&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis4&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis5&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis6&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis7&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis8&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis9&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis10&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis11&quot;, &quot;hollischuang&quot;);\nmap.put(&quot;hollis12&quot;, &quot;hollischuang&quot;);\nClass&lt;?&gt; mapType = map.getClass();\n\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(&quot;size&quot;);\nsize.setAccessible(true);\nSystem.out.println(&quot;size : &quot; + size.get(map));\n\nField threshold = mapType.getDeclaredField(&quot;threshold&quot;);\nthreshold.setAccessible(true);\nSystem.out.println(&quot;threshold : &quot; + threshold.get(map));\n\nField loadFactor = mapType.getDeclaredField(&quot;loadFactor&quot;);\nloadFactor.setAccessible(true);\nSystem.out.println(&quot;loadFactor : &quot; + loadFactor.get(map));\n\nmap.put(&quot;hollis13&quot;, &quot;hollischuang&quot;);\nMethod capacity = mapType.getDeclaredMethod(&quot;capacity&quot;);\ncapacity.setAccessible(true);\nSystem.out.println(&quot;capacity : &quot; + capacity.invoke(map));\n\nField size = mapType.getDeclaredField(&quot;size&quot;);\nsize.setAccessible(true);\nSystem.out.println(&quot;size : &quot; + size.get(map));\n\nField threshold = mapType.getDeclaredField(&quot;threshold&quot;);\nthreshold.setAccessible(true);\nSystem.out.println(&quot;threshold : &quot; + threshold.get(map));\n\nField loadFactor = mapType.getDeclaredField(&quot;loadFactor&quot;);\nloadFactor.setAccessible(true);\nSystem.out.println(&quot;loadFactor : &quot; + loadFactor.get(map));\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"java\">capacity : 16\nsize : 12\nthreshold : 12\nloadFactor : 0.75\n\ncapacity : 32\nsize : 13\nthreshold : 24\nloadFactor : 0.75\n</code></pre>\n<p>当HashMap中的元素个数达到13的时候，capacity就从16扩容到32了。</p>\n<p>HashMap中还提供了一个支持传入initialCapacity,loadFactor两个参数的方法，来初始化容量和装载因子。不过，一般不建议修改loadFactor的值。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>HashMap中size表示当前共有多少个KV对，capacity表示当前HashMap的容量是多少，默认值是16，每次扩容都是成倍的。loadFactor是装载因子，当Map中元素个数超过<code>loadFactor* capacity</code>的值时，会触发扩容。<code>loadFactor* capacity</code>可以用threshold表示。</p>\n"},{"title":"搭建本地私有docker仓库","date":"2017-06-27T12:50:14.000Z","_content":"\n# 系统\nUbuntu\n# 依赖环境\n```bash\ndocker\nClient: Version: 18.05.0-ce API version: 1.37 Go version: go1.9.5 Git commit: f150324 Built: Wed May 9 22:16:25 2017\nOS/Arch: linux/amd64 Experimental: false Orchestrator: swarm\nServer:\nEngine:\nVersion: 18.05.0-ce\nAPI version: 1.37 (minimum version 1.12)\nGo version: go1.9.5\nGit commit: f150324\nOS/Arch: linux/amd64\nExperimental: false\n```\n## 1、拉取registry镜像\n```bash\ndocker pull registry\n```\n## 2、启动仓库\n``` bash\ndocker run -d --name=my-docker-registry --restart=always -p 5000:5000 -v /opt/data/registry:/tmp/registry registry\n#这里说明下： - `--name`是启动镜像后容器的名字 - `-p`是映射的端口 - `-v`是挂载主机目录 /opt/data/registry 到容器的 /tmp/registry ，用于存储 push 进去的镜像文件，这里前面是主机的目录，你可以随意修改的 启动完毕后，执行：\ndocker ps -a\n#看到的是这样的输出说明就启动OK了\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\n4478264183c6 registry \"/entrypoint.sh /etc…\" 14 seconds ago Up 9 seconds 0.0.0.0:5000->5000/tcp my-docker-registry\n```\n\n## 3、在宿主机本地测试仓库\n``` bash\ndocker pull nginx\n```\n\n## 4、给上面镜像重新打上tag\n``` bash\ndocker tag nginx localhost:5000/my-nginx:1.0\n```\n这里解释下镜像的名字： `localhost:5000`是镜像仓库的地址， `/`后面的接的是镜像的名字，之后的`:`后面接的是版本号。\n\n## 5、上传到仓库\n``` bash\ndocker push localhost:5000/my-nginx:1.0\n```\n\n## 6、拉取仓库里面的镜像\n``` bash\ndocker pull localhost:5000/my-nginx:1.0\n```\n\n\n\n","source":"_posts/搭建本地私有docker仓库.md","raw":"---\ntitle: 搭建本地私有docker仓库\ndate: 2017-06-27 20:50:14\ntags:\n    - Docker\n    - 云计算\n    - 大数据\ncategories:\n    - 学习笔记\n---\n\n# 系统\nUbuntu\n# 依赖环境\n```bash\ndocker\nClient: Version: 18.05.0-ce API version: 1.37 Go version: go1.9.5 Git commit: f150324 Built: Wed May 9 22:16:25 2017\nOS/Arch: linux/amd64 Experimental: false Orchestrator: swarm\nServer:\nEngine:\nVersion: 18.05.0-ce\nAPI version: 1.37 (minimum version 1.12)\nGo version: go1.9.5\nGit commit: f150324\nOS/Arch: linux/amd64\nExperimental: false\n```\n## 1、拉取registry镜像\n```bash\ndocker pull registry\n```\n## 2、启动仓库\n``` bash\ndocker run -d --name=my-docker-registry --restart=always -p 5000:5000 -v /opt/data/registry:/tmp/registry registry\n#这里说明下： - `--name`是启动镜像后容器的名字 - `-p`是映射的端口 - `-v`是挂载主机目录 /opt/data/registry 到容器的 /tmp/registry ，用于存储 push 进去的镜像文件，这里前面是主机的目录，你可以随意修改的 启动完毕后，执行：\ndocker ps -a\n#看到的是这样的输出说明就启动OK了\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\n4478264183c6 registry \"/entrypoint.sh /etc…\" 14 seconds ago Up 9 seconds 0.0.0.0:5000->5000/tcp my-docker-registry\n```\n\n## 3、在宿主机本地测试仓库\n``` bash\ndocker pull nginx\n```\n\n## 4、给上面镜像重新打上tag\n``` bash\ndocker tag nginx localhost:5000/my-nginx:1.0\n```\n这里解释下镜像的名字： `localhost:5000`是镜像仓库的地址， `/`后面的接的是镜像的名字，之后的`:`后面接的是版本号。\n\n## 5、上传到仓库\n``` bash\ndocker push localhost:5000/my-nginx:1.0\n```\n\n## 6、拉取仓库里面的镜像\n``` bash\ndocker pull localhost:5000/my-nginx:1.0\n```\n\n\n\n","slug":"搭建本地私有docker仓库","published":1,"updated":"2018-07-10T07:59:45.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjfplfiw0006cwp6a9r718v8","content":"<h1><span id=\"系统\">系统</span></h1><p>Ubuntu</p>\n<h1><span id=\"依赖环境\">依赖环境</span></h1><pre><code class=\"bash\">docker\nClient: Version: 18.05.0-ce API version: 1.37 Go version: go1.9.5 Git commit: f150324 Built: Wed May 9 22:16:25 2017\nOS/Arch: linux/amd64 Experimental: false Orchestrator: swarm\nServer:\nEngine:\nVersion: 18.05.0-ce\nAPI version: 1.37 (minimum version 1.12)\nGo version: go1.9.5\nGit commit: f150324\nOS/Arch: linux/amd64\nExperimental: false\n</code></pre>\n<h2><span id=\"1-拉取registry镜像\">1、拉取registry镜像</span></h2><pre><code class=\"bash\">docker pull registry\n</code></pre>\n<h2><span id=\"2-启动仓库\">2、启动仓库</span></h2><pre><code class=\"bash\">docker run -d --name=my-docker-registry --restart=always -p 5000:5000 -v /opt/data/registry:/tmp/registry registry\n#这里说明下： - `--name`是启动镜像后容器的名字 - `-p`是映射的端口 - `-v`是挂载主机目录 /opt/data/registry 到容器的 /tmp/registry ，用于存储 push 进去的镜像文件，这里前面是主机的目录，你可以随意修改的 启动完毕后，执行：\ndocker ps -a\n#看到的是这样的输出说明就启动OK了\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\n4478264183c6 registry &quot;/entrypoint.sh /etc…&quot; 14 seconds ago Up 9 seconds 0.0.0.0:5000-&gt;5000/tcp my-docker-registry\n</code></pre>\n<h2><span id=\"3-在宿主机本地测试仓库\">3、在宿主机本地测试仓库</span></h2><pre><code class=\"bash\">docker pull nginx\n</code></pre>\n<h2><span id=\"4-给上面镜像重新打上tag\">4、给上面镜像重新打上tag</span></h2><pre><code class=\"bash\">docker tag nginx localhost:5000/my-nginx:1.0\n</code></pre>\n<p>这里解释下镜像的名字： <code>localhost:5000</code>是镜像仓库的地址， <code>/</code>后面的接的是镜像的名字，之后的<code>:</code>后面接的是版本号。</p>\n<h2><span id=\"5-上传到仓库\">5、上传到仓库</span></h2><pre><code class=\"bash\">docker push localhost:5000/my-nginx:1.0\n</code></pre>\n<h2><span id=\"6-拉取仓库里面的镜像\">6、拉取仓库里面的镜像</span></h2><pre><code class=\"bash\">docker pull localhost:5000/my-nginx:1.0\n</code></pre>\n","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":"<h1 id=\"系统\"><a href=\"#系统\" class=\"headerlink\" title=\"系统\"></a>系统</h1><p>Ubuntu</p>\n<h1 id=\"依赖环境\"><a href=\"#依赖环境\" class=\"headerlink\" title=\"依赖环境\"></a>依赖环境</h1><pre><code class=\"bash\">docker\nClient: Version: 18.05.0-ce API version: 1.37 Go version: go1.9.5 Git commit: f150324 Built: Wed May 9 22:16:25 2017\nOS/Arch: linux/amd64 Experimental: false Orchestrator: swarm\nServer:\nEngine:\nVersion: 18.05.0-ce\nAPI version: 1.37 (minimum version 1.12)\nGo version: go1.9.5\nGit commit: f150324\nOS/Arch: linux/amd64\nExperimental: false\n</code></pre>\n<h2 id=\"1、拉取registry镜像\"><a href=\"#1、拉取registry镜像\" class=\"headerlink\" title=\"1、拉取registry镜像\"></a>1、拉取registry镜像</h2><pre><code class=\"bash\">docker pull registry\n</code></pre>\n<h2 id=\"2、启动仓库\"><a href=\"#2、启动仓库\" class=\"headerlink\" title=\"2、启动仓库\"></a>2、启动仓库</h2><pre><code class=\"bash\">docker run -d --name=my-docker-registry --restart=always -p 5000:5000 -v /opt/data/registry:/tmp/registry registry\n#这里说明下： - `--name`是启动镜像后容器的名字 - `-p`是映射的端口 - `-v`是挂载主机目录 /opt/data/registry 到容器的 /tmp/registry ，用于存储 push 进去的镜像文件，这里前面是主机的目录，你可以随意修改的 启动完毕后，执行：\ndocker ps -a\n#看到的是这样的输出说明就启动OK了\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\n4478264183c6 registry &quot;/entrypoint.sh /etc…&quot; 14 seconds ago Up 9 seconds 0.0.0.0:5000-&gt;5000/tcp my-docker-registry\n</code></pre>\n<h2 id=\"3、在宿主机本地测试仓库\"><a href=\"#3、在宿主机本地测试仓库\" class=\"headerlink\" title=\"3、在宿主机本地测试仓库\"></a>3、在宿主机本地测试仓库</h2><pre><code class=\"bash\">docker pull nginx\n</code></pre>\n<h2 id=\"4、给上面镜像重新打上tag\"><a href=\"#4、给上面镜像重新打上tag\" class=\"headerlink\" title=\"4、给上面镜像重新打上tag\"></a>4、给上面镜像重新打上tag</h2><pre><code class=\"bash\">docker tag nginx localhost:5000/my-nginx:1.0\n</code></pre>\n<p>这里解释下镜像的名字： <code>localhost:5000</code>是镜像仓库的地址， <code>/</code>后面的接的是镜像的名字，之后的<code>:</code>后面接的是版本号。</p>\n<h2 id=\"5、上传到仓库\"><a href=\"#5、上传到仓库\" class=\"headerlink\" title=\"5、上传到仓库\"></a>5、上传到仓库</h2><pre><code class=\"bash\">docker push localhost:5000/my-nginx:1.0\n</code></pre>\n<h2 id=\"6、拉取仓库里面的镜像\"><a href=\"#6、拉取仓库里面的镜像\" class=\"headerlink\" title=\"6、拉取仓库里面的镜像\"></a>6、拉取仓库里面的镜像</h2><pre><code class=\"bash\">docker pull localhost:5000/my-nginx:1.0\n</code></pre>\n"},{"title":"SpringBoot入门最详细教程","date":"2017-06-27T13:29:56.000Z","thumbnail":"https://img.szpinc.org/2018-06-27-zdsfdsf123sdf.jpeg","_content":"\n网上有很多springboot的入门教程，自己也因为项目要使用springboot，所以利用业余时间自学了下springboot和springcloud，使用下来发现springboot还是挺简单的，体现了极简的编程风格，大部分通用都是通过注解就可以完成，下面就来详细讲解下如何使用springboot来开发一个简单的restful api网关功能，可以提供给H5或者android、ios进行接口开发，还是很方便的。\n\n## 1. 使用spring initialization创建SpringBoot项目\n有很多方法可以快速创建Springboot项目，可以通过idea的springboot initialization来创建，也可以通过手工新建一个maven工程，然后引入springboot的dependency来完成sprignboot的工程导入，还可以通过spring官网的来创建springboot项目，因为有些同学可能没装idea，这里就通过官网的工程初始化指引来创建一个springboot空工程。\n首先输入网址 [https://start.spring.io](https://start.spring.io)，打开后可以看到下图：\n\n![4720632-ba521ad471d4535e](https://img.szpinc.org/2018-06-27-4720632-ba521ad471d4535e.png)\n\n在serch for dependency输入web，即可完成基本的restful接口网关的功能，如果要JPA或者oauth安全相关的组件，可以增加rest repository、spring security等相关组件依赖库，spring提供的配套组件还是很多的，基本涵盖了所有应用场合。\n加入web组件后，点击下方的绿色按钮Generate Project即可创建一个springboot工程，并且自动下载到本地，接下来直接在idea或者eclipse打开该工程就可以了，在创建的时候可以选择Maven工程或者Gradle工程，这里我们使用了大家比较熟悉的Maven工程。\n## 2. 工程结构\n下面我们在ide中打开工程，这里使用的ide是idea，工程的目录结构为：\n![4720632-36efce4a9e15f490](https://img.szpinc.org/2018-06-27-4720632-36efce4a9e15f490.png)\n\n可以看到工程中有maven的pom文件，也自动创建了SpringbootStartApplication.java该类为springboot的启动类，待会儿我们一起看下这个类，先看下maven的pom文件有哪些。这里主要是依赖了springboot的1.4.7版本，目前最新已经更新到1.5.6了，这里没有用最新版本，还是不当小白鼠了，在dependency中依赖了spring-boot-starter-web还有个test测试的组件，如果不写测试代码，可以不使用该test组件，最后还加入了支持springboot的maven plugin组件。\n\n``` xml\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.4.7.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n```\n配置好了pom后，我们一起看下自动生成的Application.java这个类相当于我们程序的main函数入口，这里再顺便介绍下因为springboot集成了Tomcat和Jetty，默认使用Tomcat作为应用容器，开发者只需要将工程打成jar包直接丢到服务器上就可以执行了，不需要再单独部署到was、jboss、tomcat这些应用服务器上。\nSpringBootStartApplication.java\n``` java\n@SpringBootApplication\npublic class SpringbootStartApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootStartApplication.class, args);\n    }\n}\n```\n\n所有的springboot application启动类都需要在类级别上加上@SpringBootApplication注解，其他参数不用任何调整，后续可以把一些初始化的动作放到该类中进行，目前本例中就不加其他的启动加载项了。\n这样一个api网关的架子就搭好了，是不是很简单！下面我们就可以将主要精力聚焦在业务逻辑代码上了，这里为了简化程序，不会将项目进行深入的分层设计，在实际项目中，一般都会对项目进行分层设计，如果是api网关，没有view层但是起码也会有对外接入decontroller层、处理业务逻辑的service层、处理数据持久化的dao层，同时也会有一些POJO业务实体类，这里就不详细展开了，后续也会对互联网架构设计进行详细讲述，这里我们只创建了一个UserController类，里面只有获取用户信息的方法，分别根据参数和请求方式的不同用三种方法进行了重写，下面就来一一道来。\n\n先来讲述下最简单的使用get请求用户信息的实现方式，代码如下,写好后直接在Application类点击右键有个RunAs，点击后会自动运行，运行成功后可以使用http发包工具进行测试，这里推荐使用chrome的postman或者使用firefox的httprequester插件，都是比较简单的发包工具，get请求的上送为\n\n[http://localhost:8081/springboot/getUserByGet?userName=feiweiwei](http://localhost:8081/springboot/getUserByGet?userName=feiweiwei)\n\n``` java\n//@RestController注解能够使项目支持Rest\n@RestController\n@SpringBootApplication\n//表示该controller类下所有的方法都公用的一级上下文根\n@RequestMapping(value = \"/springboot\")\npublic class UserController {\n    //这里使用@RequestMapping注解表示该方法对应的二级上下文路径\n    @RequestMapping(value = \"/getUserByGet\", method = RequestMethod.GET)\n    String getUserByGet(@RequestParam(value = \"userName\") String userName){\n        return \"Hello \" + userName;\n    }\n}\n```\n\n这里用到的注解主要有@RequestMapping表示请求的URL上下文路径，该路径不能重复，为了保证与团队其他同事写的不重复，一般会在每个controller前面加一个一级上下文目录，具体路径参数放在value后面，在每个方法前加一个二级目录，这样可以有效的避免路径冲突。还有注解是@RequestParam，该注解可以通过value指定入参，这里return的返回值就是实际的接口返回。\n\n下面介绍下POST的请求方式，可以通过在@RequestMapping注解中设置method为POST来表示该请求为POST请求，除了get、post还有put、delete等请求方式，都可以通过该参数设置。\n\n``` java\n    //通过RequestMethod.POST表示请求需要时POST方式\n    @RequestMapping(value = \"/getUserByPost\", method = RequestMethod.POST)\n    String getUserByPost(@RequestParam(value = \"userName\") String userName){\n        return \"Hello \" + userName;\n    }\n```\n\n下面介绍下请求参数为JSON格式的请求方法的写法，这里需要注意下如果请求参数是像上面那样通过url form形式提交的请求参数，那么必须使用@RequestParam注解来标示参数，如果使用的请求报文是POST形势的JSON串，那么这里在入参的注解一定要使用@RequestBody，否则会报json解析错误。\n\n``` java\n    //在入参设置@RequestBody注解表示接收整个报文体，这里主要用在接收整个POST请求中的json报文体，\n    //目前主流的请求报文也都是JSON格式了，使用该注解就能够获取整个JSON报文体作为入参，使用JSON解析工具解析后获取具体参数\n    @RequestMapping(value = \"/getUserByJson\",method = RequestMethod.POST)\n    String getUserByJson(@RequestBody String data){\n        return \"Json is \" + data;\n    }\n```\n## 3. 小结\n到此一个简单的restful风格的api网关就完成了，对于移动开发人员可以自己写简单的服务端进行全栈开发了，原来做spring的同学也可以很快上手springboot，springboot总体上来说还是简化了原先复杂的配置，让大家更容易快速上手和搭建服务端，代码的git地址在下方，欢迎大家下载，谢谢。\n\n\n\n","source":"_posts/SpringBoot入门最详细教程.md","raw":"---\ntitle: SpringBoot入门最详细教程\ndate: 2017-06-27 21:29:56\nthumbnail: https://img.szpinc.org/2018-06-27-zdsfdsf123sdf.jpeg\ntags:\n    - springboot\ncategories:\n    - java\n    - 学习笔记\n---\n\n网上有很多springboot的入门教程，自己也因为项目要使用springboot，所以利用业余时间自学了下springboot和springcloud，使用下来发现springboot还是挺简单的，体现了极简的编程风格，大部分通用都是通过注解就可以完成，下面就来详细讲解下如何使用springboot来开发一个简单的restful api网关功能，可以提供给H5或者android、ios进行接口开发，还是很方便的。\n\n## 1. 使用spring initialization创建SpringBoot项目\n有很多方法可以快速创建Springboot项目，可以通过idea的springboot initialization来创建，也可以通过手工新建一个maven工程，然后引入springboot的dependency来完成sprignboot的工程导入，还可以通过spring官网的来创建springboot项目，因为有些同学可能没装idea，这里就通过官网的工程初始化指引来创建一个springboot空工程。\n首先输入网址 [https://start.spring.io](https://start.spring.io)，打开后可以看到下图：\n\n![4720632-ba521ad471d4535e](https://img.szpinc.org/2018-06-27-4720632-ba521ad471d4535e.png)\n\n在serch for dependency输入web，即可完成基本的restful接口网关的功能，如果要JPA或者oauth安全相关的组件，可以增加rest repository、spring security等相关组件依赖库，spring提供的配套组件还是很多的，基本涵盖了所有应用场合。\n加入web组件后，点击下方的绿色按钮Generate Project即可创建一个springboot工程，并且自动下载到本地，接下来直接在idea或者eclipse打开该工程就可以了，在创建的时候可以选择Maven工程或者Gradle工程，这里我们使用了大家比较熟悉的Maven工程。\n## 2. 工程结构\n下面我们在ide中打开工程，这里使用的ide是idea，工程的目录结构为：\n![4720632-36efce4a9e15f490](https://img.szpinc.org/2018-06-27-4720632-36efce4a9e15f490.png)\n\n可以看到工程中有maven的pom文件，也自动创建了SpringbootStartApplication.java该类为springboot的启动类，待会儿我们一起看下这个类，先看下maven的pom文件有哪些。这里主要是依赖了springboot的1.4.7版本，目前最新已经更新到1.5.6了，这里没有用最新版本，还是不当小白鼠了，在dependency中依赖了spring-boot-starter-web还有个test测试的组件，如果不写测试代码，可以不使用该test组件，最后还加入了支持springboot的maven plugin组件。\n\n``` xml\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.4.7.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n```\n配置好了pom后，我们一起看下自动生成的Application.java这个类相当于我们程序的main函数入口，这里再顺便介绍下因为springboot集成了Tomcat和Jetty，默认使用Tomcat作为应用容器，开发者只需要将工程打成jar包直接丢到服务器上就可以执行了，不需要再单独部署到was、jboss、tomcat这些应用服务器上。\nSpringBootStartApplication.java\n``` java\n@SpringBootApplication\npublic class SpringbootStartApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootStartApplication.class, args);\n    }\n}\n```\n\n所有的springboot application启动类都需要在类级别上加上@SpringBootApplication注解，其他参数不用任何调整，后续可以把一些初始化的动作放到该类中进行，目前本例中就不加其他的启动加载项了。\n这样一个api网关的架子就搭好了，是不是很简单！下面我们就可以将主要精力聚焦在业务逻辑代码上了，这里为了简化程序，不会将项目进行深入的分层设计，在实际项目中，一般都会对项目进行分层设计，如果是api网关，没有view层但是起码也会有对外接入decontroller层、处理业务逻辑的service层、处理数据持久化的dao层，同时也会有一些POJO业务实体类，这里就不详细展开了，后续也会对互联网架构设计进行详细讲述，这里我们只创建了一个UserController类，里面只有获取用户信息的方法，分别根据参数和请求方式的不同用三种方法进行了重写，下面就来一一道来。\n\n先来讲述下最简单的使用get请求用户信息的实现方式，代码如下,写好后直接在Application类点击右键有个RunAs，点击后会自动运行，运行成功后可以使用http发包工具进行测试，这里推荐使用chrome的postman或者使用firefox的httprequester插件，都是比较简单的发包工具，get请求的上送为\n\n[http://localhost:8081/springboot/getUserByGet?userName=feiweiwei](http://localhost:8081/springboot/getUserByGet?userName=feiweiwei)\n\n``` java\n//@RestController注解能够使项目支持Rest\n@RestController\n@SpringBootApplication\n//表示该controller类下所有的方法都公用的一级上下文根\n@RequestMapping(value = \"/springboot\")\npublic class UserController {\n    //这里使用@RequestMapping注解表示该方法对应的二级上下文路径\n    @RequestMapping(value = \"/getUserByGet\", method = RequestMethod.GET)\n    String getUserByGet(@RequestParam(value = \"userName\") String userName){\n        return \"Hello \" + userName;\n    }\n}\n```\n\n这里用到的注解主要有@RequestMapping表示请求的URL上下文路径，该路径不能重复，为了保证与团队其他同事写的不重复，一般会在每个controller前面加一个一级上下文目录，具体路径参数放在value后面，在每个方法前加一个二级目录，这样可以有效的避免路径冲突。还有注解是@RequestParam，该注解可以通过value指定入参，这里return的返回值就是实际的接口返回。\n\n下面介绍下POST的请求方式，可以通过在@RequestMapping注解中设置method为POST来表示该请求为POST请求，除了get、post还有put、delete等请求方式，都可以通过该参数设置。\n\n``` java\n    //通过RequestMethod.POST表示请求需要时POST方式\n    @RequestMapping(value = \"/getUserByPost\", method = RequestMethod.POST)\n    String getUserByPost(@RequestParam(value = \"userName\") String userName){\n        return \"Hello \" + userName;\n    }\n```\n\n下面介绍下请求参数为JSON格式的请求方法的写法，这里需要注意下如果请求参数是像上面那样通过url form形式提交的请求参数，那么必须使用@RequestParam注解来标示参数，如果使用的请求报文是POST形势的JSON串，那么这里在入参的注解一定要使用@RequestBody，否则会报json解析错误。\n\n``` java\n    //在入参设置@RequestBody注解表示接收整个报文体，这里主要用在接收整个POST请求中的json报文体，\n    //目前主流的请求报文也都是JSON格式了，使用该注解就能够获取整个JSON报文体作为入参，使用JSON解析工具解析后获取具体参数\n    @RequestMapping(value = \"/getUserByJson\",method = RequestMethod.POST)\n    String getUserByJson(@RequestBody String data){\n        return \"Json is \" + data;\n    }\n```\n## 3. 小结\n到此一个简单的restful风格的api网关就完成了，对于移动开发人员可以自己写简单的服务端进行全栈开发了，原来做spring的同学也可以很快上手springboot，springboot总体上来说还是简化了原先复杂的配置，让大家更容易快速上手和搭建服务端，代码的git地址在下方，欢迎大家下载，谢谢。\n\n\n\n","slug":"SpringBoot入门最详细教程","published":1,"updated":"2018-07-10T07:59:45.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjfplfjq000ucwp6ubrfi5ho","content":"<p>网上有很多springboot的入门教程，自己也因为项目要使用springboot，所以利用业余时间自学了下springboot和springcloud，使用下来发现springboot还是挺简单的，体现了极简的编程风格，大部分通用都是通过注解就可以完成，下面就来详细讲解下如何使用springboot来开发一个简单的restful api网关功能，可以提供给H5或者android、ios进行接口开发，还是很方便的。</p>\n<h2><span id=\"1-使用spring-initialization创建springboot项目\">1. 使用spring initialization创建SpringBoot项目</span></h2><p>有很多方法可以快速创建Springboot项目，可以通过idea的springboot initialization来创建，也可以通过手工新建一个maven工程，然后引入springboot的dependency来完成sprignboot的工程导入，还可以通过spring官网的来创建springboot项目，因为有些同学可能没装idea，这里就通过官网的工程初始化指引来创建一个springboot空工程。<br>首先输入网址 <a href=\"https://start.spring.io\" target=\"_blank\" rel=\"noopener\">https://start.spring.io</a>，打开后可以看到下图：</p>\n<p><img src=\"https://img.szpinc.org/2018-06-27-4720632-ba521ad471d4535e.png\" alt=\"4720632-ba521ad471d4535e\"></p>\n<p>在serch for dependency输入web，即可完成基本的restful接口网关的功能，如果要JPA或者oauth安全相关的组件，可以增加rest repository、spring security等相关组件依赖库，spring提供的配套组件还是很多的，基本涵盖了所有应用场合。<br>加入web组件后，点击下方的绿色按钮Generate Project即可创建一个springboot工程，并且自动下载到本地，接下来直接在idea或者eclipse打开该工程就可以了，在创建的时候可以选择Maven工程或者Gradle工程，这里我们使用了大家比较熟悉的Maven工程。</p>\n<h2><span id=\"2-工程结构\">2. 工程结构</span></h2><p>下面我们在ide中打开工程，这里使用的ide是idea，工程的目录结构为：<br><img src=\"https://img.szpinc.org/2018-06-27-4720632-36efce4a9e15f490.png\" alt=\"4720632-36efce4a9e15f490\"></p>\n<p>可以看到工程中有maven的pom文件，也自动创建了SpringbootStartApplication.java该类为springboot的启动类，待会儿我们一起看下这个类，先看下maven的pom文件有哪些。这里主要是依赖了springboot的1.4.7版本，目前最新已经更新到1.5.6了，这里没有用最新版本，还是不当小白鼠了，在dependency中依赖了spring-boot-starter-web还有个test测试的组件，如果不写测试代码，可以不使用该test组件，最后还加入了支持springboot的maven plugin组件。</p>\n<pre><code class=\"xml\">&lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n</code></pre>\n<p>配置好了pom后，我们一起看下自动生成的Application.java这个类相当于我们程序的main函数入口，这里再顺便介绍下因为springboot集成了Tomcat和Jetty，默认使用Tomcat作为应用容器，开发者只需要将工程打成jar包直接丢到服务器上就可以执行了，不需要再单独部署到was、jboss、tomcat这些应用服务器上。<br>SpringBootStartApplication.java</p>\n<pre><code class=\"java\">@SpringBootApplication\npublic class SpringbootStartApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootStartApplication.class, args);\n    }\n}\n</code></pre>\n<p>所有的springboot application启动类都需要在类级别上加上@SpringBootApplication注解，其他参数不用任何调整，后续可以把一些初始化的动作放到该类中进行，目前本例中就不加其他的启动加载项了。<br>这样一个api网关的架子就搭好了，是不是很简单！下面我们就可以将主要精力聚焦在业务逻辑代码上了，这里为了简化程序，不会将项目进行深入的分层设计，在实际项目中，一般都会对项目进行分层设计，如果是api网关，没有view层但是起码也会有对外接入decontroller层、处理业务逻辑的service层、处理数据持久化的dao层，同时也会有一些POJO业务实体类，这里就不详细展开了，后续也会对互联网架构设计进行详细讲述，这里我们只创建了一个UserController类，里面只有获取用户信息的方法，分别根据参数和请求方式的不同用三种方法进行了重写，下面就来一一道来。</p>\n<p>先来讲述下最简单的使用get请求用户信息的实现方式，代码如下,写好后直接在Application类点击右键有个RunAs，点击后会自动运行，运行成功后可以使用http发包工具进行测试，这里推荐使用chrome的postman或者使用firefox的httprequester插件，都是比较简单的发包工具，get请求的上送为</p>\n<p><a href=\"http://localhost:8081/springboot/getUserByGet?userName=feiweiwei\" target=\"_blank\" rel=\"noopener\">http://localhost:8081/springboot/getUserByGet?userName=feiweiwei</a></p>\n<pre><code class=\"java\">//@RestController注解能够使项目支持Rest\n@RestController\n@SpringBootApplication\n//表示该controller类下所有的方法都公用的一级上下文根\n@RequestMapping(value = &quot;/springboot&quot;)\npublic class UserController {\n    //这里使用@RequestMapping注解表示该方法对应的二级上下文路径\n    @RequestMapping(value = &quot;/getUserByGet&quot;, method = RequestMethod.GET)\n    String getUserByGet(@RequestParam(value = &quot;userName&quot;) String userName){\n        return &quot;Hello &quot; + userName;\n    }\n}\n</code></pre>\n<p>这里用到的注解主要有@RequestMapping表示请求的URL上下文路径，该路径不能重复，为了保证与团队其他同事写的不重复，一般会在每个controller前面加一个一级上下文目录，具体路径参数放在value后面，在每个方法前加一个二级目录，这样可以有效的避免路径冲突。还有注解是@RequestParam，该注解可以通过value指定入参，这里return的返回值就是实际的接口返回。</p>\n<p>下面介绍下POST的请求方式，可以通过在@RequestMapping注解中设置method为POST来表示该请求为POST请求，除了get、post还有put、delete等请求方式，都可以通过该参数设置。</p>\n<pre><code class=\"java\">    //通过RequestMethod.POST表示请求需要时POST方式\n    @RequestMapping(value = &quot;/getUserByPost&quot;, method = RequestMethod.POST)\n    String getUserByPost(@RequestParam(value = &quot;userName&quot;) String userName){\n        return &quot;Hello &quot; + userName;\n    }\n</code></pre>\n<p>下面介绍下请求参数为JSON格式的请求方法的写法，这里需要注意下如果请求参数是像上面那样通过url form形式提交的请求参数，那么必须使用@RequestParam注解来标示参数，如果使用的请求报文是POST形势的JSON串，那么这里在入参的注解一定要使用@RequestBody，否则会报json解析错误。</p>\n<pre><code class=\"java\">    //在入参设置@RequestBody注解表示接收整个报文体，这里主要用在接收整个POST请求中的json报文体，\n    //目前主流的请求报文也都是JSON格式了，使用该注解就能够获取整个JSON报文体作为入参，使用JSON解析工具解析后获取具体参数\n    @RequestMapping(value = &quot;/getUserByJson&quot;,method = RequestMethod.POST)\n    String getUserByJson(@RequestBody String data){\n        return &quot;Json is &quot; + data;\n    }\n</code></pre>\n<h2><span id=\"3-小结\">3. 小结</span></h2><p>到此一个简单的restful风格的api网关就完成了，对于移动开发人员可以自己写简单的服务端进行全栈开发了，原来做spring的同学也可以很快上手springboot，springboot总体上来说还是简化了原先复杂的配置，让大家更容易快速上手和搭建服务端，代码的git地址在下方，欢迎大家下载，谢谢。</p>\n","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":"<p>网上有很多springboot的入门教程，自己也因为项目要使用springboot，所以利用业余时间自学了下springboot和springcloud，使用下来发现springboot还是挺简单的，体现了极简的编程风格，大部分通用都是通过注解就可以完成，下面就来详细讲解下如何使用springboot来开发一个简单的restful api网关功能，可以提供给H5或者android、ios进行接口开发，还是很方便的。</p>\n<h2 id=\"1-使用spring-initialization创建SpringBoot项目\"><a href=\"#1-使用spring-initialization创建SpringBoot项目\" class=\"headerlink\" title=\"1. 使用spring initialization创建SpringBoot项目\"></a>1. 使用spring initialization创建SpringBoot项目</h2><p>有很多方法可以快速创建Springboot项目，可以通过idea的springboot initialization来创建，也可以通过手工新建一个maven工程，然后引入springboot的dependency来完成sprignboot的工程导入，还可以通过spring官网的来创建springboot项目，因为有些同学可能没装idea，这里就通过官网的工程初始化指引来创建一个springboot空工程。<br>首先输入网址 <a href=\"https://start.spring.io\" target=\"_blank\" rel=\"noopener\">https://start.spring.io</a>，打开后可以看到下图：</p>\n<p><img src=\"https://img.szpinc.org/2018-06-27-4720632-ba521ad471d4535e.png\" alt=\"4720632-ba521ad471d4535e\"></p>\n<p>在serch for dependency输入web，即可完成基本的restful接口网关的功能，如果要JPA或者oauth安全相关的组件，可以增加rest repository、spring security等相关组件依赖库，spring提供的配套组件还是很多的，基本涵盖了所有应用场合。<br>加入web组件后，点击下方的绿色按钮Generate Project即可创建一个springboot工程，并且自动下载到本地，接下来直接在idea或者eclipse打开该工程就可以了，在创建的时候可以选择Maven工程或者Gradle工程，这里我们使用了大家比较熟悉的Maven工程。</p>\n<h2 id=\"2-工程结构\"><a href=\"#2-工程结构\" class=\"headerlink\" title=\"2. 工程结构\"></a>2. 工程结构</h2><p>下面我们在ide中打开工程，这里使用的ide是idea，工程的目录结构为：<br><img src=\"https://img.szpinc.org/2018-06-27-4720632-36efce4a9e15f490.png\" alt=\"4720632-36efce4a9e15f490\"></p>\n<p>可以看到工程中有maven的pom文件，也自动创建了SpringbootStartApplication.java该类为springboot的启动类，待会儿我们一起看下这个类，先看下maven的pom文件有哪些。这里主要是依赖了springboot的1.4.7版本，目前最新已经更新到1.5.6了，这里没有用最新版本，还是不当小白鼠了，在dependency中依赖了spring-boot-starter-web还有个test测试的组件，如果不写测试代码，可以不使用该test组件，最后还加入了支持springboot的maven plugin组件。</p>\n<pre><code class=\"xml\">&lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n</code></pre>\n<p>配置好了pom后，我们一起看下自动生成的Application.java这个类相当于我们程序的main函数入口，这里再顺便介绍下因为springboot集成了Tomcat和Jetty，默认使用Tomcat作为应用容器，开发者只需要将工程打成jar包直接丢到服务器上就可以执行了，不需要再单独部署到was、jboss、tomcat这些应用服务器上。<br>SpringBootStartApplication.java</p>\n<pre><code class=\"java\">@SpringBootApplication\npublic class SpringbootStartApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootStartApplication.class, args);\n    }\n}\n</code></pre>\n<p>所有的springboot application启动类都需要在类级别上加上@SpringBootApplication注解，其他参数不用任何调整，后续可以把一些初始化的动作放到该类中进行，目前本例中就不加其他的启动加载项了。<br>这样一个api网关的架子就搭好了，是不是很简单！下面我们就可以将主要精力聚焦在业务逻辑代码上了，这里为了简化程序，不会将项目进行深入的分层设计，在实际项目中，一般都会对项目进行分层设计，如果是api网关，没有view层但是起码也会有对外接入decontroller层、处理业务逻辑的service层、处理数据持久化的dao层，同时也会有一些POJO业务实体类，这里就不详细展开了，后续也会对互联网架构设计进行详细讲述，这里我们只创建了一个UserController类，里面只有获取用户信息的方法，分别根据参数和请求方式的不同用三种方法进行了重写，下面就来一一道来。</p>\n<p>先来讲述下最简单的使用get请求用户信息的实现方式，代码如下,写好后直接在Application类点击右键有个RunAs，点击后会自动运行，运行成功后可以使用http发包工具进行测试，这里推荐使用chrome的postman或者使用firefox的httprequester插件，都是比较简单的发包工具，get请求的上送为</p>\n<p><a href=\"http://localhost:8081/springboot/getUserByGet?userName=feiweiwei\" target=\"_blank\" rel=\"noopener\">http://localhost:8081/springboot/getUserByGet?userName=feiweiwei</a></p>\n<pre><code class=\"java\">//@RestController注解能够使项目支持Rest\n@RestController\n@SpringBootApplication\n//表示该controller类下所有的方法都公用的一级上下文根\n@RequestMapping(value = &quot;/springboot&quot;)\npublic class UserController {\n    //这里使用@RequestMapping注解表示该方法对应的二级上下文路径\n    @RequestMapping(value = &quot;/getUserByGet&quot;, method = RequestMethod.GET)\n    String getUserByGet(@RequestParam(value = &quot;userName&quot;) String userName){\n        return &quot;Hello &quot; + userName;\n    }\n}\n</code></pre>\n<p>这里用到的注解主要有@RequestMapping表示请求的URL上下文路径，该路径不能重复，为了保证与团队其他同事写的不重复，一般会在每个controller前面加一个一级上下文目录，具体路径参数放在value后面，在每个方法前加一个二级目录，这样可以有效的避免路径冲突。还有注解是@RequestParam，该注解可以通过value指定入参，这里return的返回值就是实际的接口返回。</p>\n<p>下面介绍下POST的请求方式，可以通过在@RequestMapping注解中设置method为POST来表示该请求为POST请求，除了get、post还有put、delete等请求方式，都可以通过该参数设置。</p>\n<pre><code class=\"java\">    //通过RequestMethod.POST表示请求需要时POST方式\n    @RequestMapping(value = &quot;/getUserByPost&quot;, method = RequestMethod.POST)\n    String getUserByPost(@RequestParam(value = &quot;userName&quot;) String userName){\n        return &quot;Hello &quot; + userName;\n    }\n</code></pre>\n<p>下面介绍下请求参数为JSON格式的请求方法的写法，这里需要注意下如果请求参数是像上面那样通过url form形式提交的请求参数，那么必须使用@RequestParam注解来标示参数，如果使用的请求报文是POST形势的JSON串，那么这里在入参的注解一定要使用@RequestBody，否则会报json解析错误。</p>\n<pre><code class=\"java\">    //在入参设置@RequestBody注解表示接收整个报文体，这里主要用在接收整个POST请求中的json报文体，\n    //目前主流的请求报文也都是JSON格式了，使用该注解就能够获取整个JSON报文体作为入参，使用JSON解析工具解析后获取具体参数\n    @RequestMapping(value = &quot;/getUserByJson&quot;,method = RequestMethod.POST)\n    String getUserByJson(@RequestBody String data){\n        return &quot;Json is &quot; + data;\n    }\n</code></pre>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>到此一个简单的restful风格的api网关就完成了，对于移动开发人员可以自己写简单的服务端进行全栈开发了，原来做spring的同学也可以很快上手springboot，springboot总体上来说还是简化了原先复杂的配置，让大家更容易快速上手和搭建服务端，代码的git地址在下方，欢迎大家下载，谢谢。</p>\n"},{"title":"Spring注解@Async和@Transactional失效问题究竟是什么原因，强势解释一波","date":"2017-07-01T13:53:39.000Z","comments":0,"_content":"\n## 提前说说\n\n项目中涉及到的代码我都会上传到码云(gitee)或者github上，提供给大家下载参考，文中就以最简单的方式说明执行过程。源码的地址在文末哦！\n\n\n\n## 问题场景重现\n\n**场景一：**\n\nSpring的异步执行注解@Async，在调用这个方法的时候发现，不对劲，耗时的逻辑我已经加入到异步取做了，怎么接口请求的响应这么慢，赶紧看日志，懵X，加了异步注解，却没有异步执行。\n\n**场景二：**\n\n在项目中用到@Transactional注解实现事务是必须滴，如果你还在用xml配置，那我只能说……。\n\n但是有时候我们会发现在方法上加了@Transactional注解却出现灵异事件，在方法内出现异常，数据还是插入到数据库，没有回滚，事务哪里去了，明明是加了的。\n\n**@Async注解实现原因分析和解决方案**\n\n在看下面的内容之前，对动态代理不是很熟悉的可以看一下我之前的一篇文章：[http://blog.zdydoit.com/blogs/2018/06/dynamic-static-proxy/](http://blog.zdydoit.com/blogs/2018/06/dynamic-static-proxy/)。\n这里添加的注解是通过Spring AOP对方法的一种增强，而Spring AOP的原理就是动态代理，他的代理有两种，分别是CGLB和JDK自带的代理，Spring AOP会根据具体的实现不同，采用不同的代理方式。\n动态代理的原理了解了，下面的问题就可以很好的理解。\n\n**异步测试接口**\n\n\n``` java\npublic interface AsyncAopService {\n   void addOrder();\n   void sendMsg(int result);\n}\n```\n\n**异步测试接口实现**\n``` java\n@Service\n@Slf4j\npublic class AsyncAopServiceImpl implements AsyncAopService {\n\n   @Autowired\n   private OrderDao orderDao;\n   @Autowired\n   private MsgDao msgDao;\n\n   /**\n    * 添加订单后会给用户异步的推送信息\n    */\n   @Transactional //这里为了让该被代理，加此注解\n   public void addOrder() {\n       int result = orderDao.insert(OrderModel.builder()\n               .amount(10000L)\n               .orderId(\"ORDER_2018042601\")\n               .phone(\"15600001212\")\n               .userId(\"U_001\")\n               .build());\n       String currentThreadName = Thread.currentThread().getName();\n       sendMsg(result);\n       System.out.println(currentThreadName + \"------>下单结束：mark\");\n   }\n\n   @Async\n   public void sendMsg(int result) {\n       try {\n           Thread thread = Thread.currentThread();\n           thread.sleep(3000);//停留3秒\n           String currentThreadName = thread.getName();\n           if (result == 1) {\n               msgDao.insert(MsgModel.builder().msgContent(\"下单成功！\").receiver(\"15600001212\").build());\n               System.out.println(currentThreadName + \"------>发送信息成功\");\n           } else {\n               msgDao.insert(MsgModel.builder().msgContent(\"下单失败！\").receiver(\"15600001212\").build());\n               System.out.println(currentThreadName + \"------>发送信息失败\");\n           }\n       } catch (Exception e) {\n           e.printStackTrace();\n       }\n   }\n}\n```\n\n**测试类**\n``` java\n@Test\npublic void AsyncTest() throws InterruptedException {\n System.out.println(\"=======async test start=======\");\n asyncAopService.addOrder();\n System.out.println(\"=======async test end=======\");\n /**\n  * 在这里让线程睡5秒的原因是为了能够看到异步执行的结果日志\n  * 小知识点：在Junit测试中，如果主线程执行结束，\n  *整个测试过程也结束了，存在的异步逻辑如果没有执行完就不会执行啦!\n  * 测试方式：把这行代码去掉，执行测试，t_order_info表中会插入数据，\n  *但是t_msg_info表中无数据插入。\n  */\n Thread.sleep(5000);\n}\n```\n\n**测试类上的注解：**\n``` java\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n```\n\n**Spring Boot启动类的注解：**\n``` java\n@SpringBootApplication\n@MapperScan(\"com.minuor.aop.dao\")\n@EnableAspectJAutoProxy\n@EnableAsync //开启异步功能\n```\n\n**测试结果**\n``` java\n=======async test start=======\nmain------>发送信息成功\nmain------>下单结束：mark\n=======async test end=======\n```\n\n运行的过程很慢，两行日志的线程名称相同，并且mark日志是在发送信息成功后再输出的，回到代码可以知道发送信息逻辑是异步的执行，为什么会和下单过程的线程名称相同，并且异步执行发送消息是延迟的，为何日志还在mark日志前。种种迹象表明，这不是一个异步执行，而是顺序执行。但是这里是加了异步的注解的，实际没有生效。\n在`addOrder()`方法里面直接调用`sendMsg(……)`方法，这里还隐含一个关键字，那就是`this`，实际上这里调用是这样的：`this.sendMsg()`,`this`是当前对象。而`addOrder()`是被代理的，在代理对象中执行结束增强后，通过`invoke`，用实际`AsyncAopServiceImpl`对象来调用`addOrder()`方法执行业务逻辑。在业务逻辑内又调用了`sendMsg(……)`方法，调用的对象是当前对象，当前对象是`AsyncAopServiceImpl`，问题就出在这里，因为要想用异步执行`sendMsg(……)`，必须用代理对象执行，因为代理对象要做异步相关的增强，但是此时却直接用AsyncAopServiceImpl对象调用，绕过了代理对象增强的部分，也就是说代理增强部分失效，`@Async`注解失效。原来想异步执行的逻辑，变成了顺序执行。\n\n**解决方案**\n\n没有用代理对象执行`sendMsg(……)`，被`AsyncAopServiceImpl`对象抢占了先机。那么解决就是要让代理对象来执行`sendMsg(……)`。\n在调用`sendMsg(……)`之前添加下面的代码\n\n``` java\nAsyncAopService service = (AsyncAopService) AopContext.currentProxy(); \n//获取代理对象\nservice.sendMsg(result); \n//通过代理对象调用sendMsg，做异步增强\n```\n这里还不算完，如果就这样运行，那肯定会报错。\n**在@EnableAspectJAutoProxy添加属性值。**\n> @EnableAspectJAutoProxy(exposeProxy = true)\n\n运行结果\n``` java\n=======async test start=======\nmain------>下单结束：mark\n=======async test end=======\nSimpleAsyncTaskExecutor-1------>发送信息成功\n```\n\n结果也是想要的结果，下单结束，整个测试结束，在测试结束后等待5秒，等待异步日志打印。主线程和异步线程是不同的两个。\n\n如果对代理对象和当前对象有点懵的话，可以加上下面的两行代码\n``` java\nSystem.out.println(\"------>代理对象：\"+service.getClass());\nSystem.out.println(\"------>当前对象：\"+this.getClass());\n```\n得到的结果：\n``` java\n------>代理对象：class com.minuor.aop.impl.AsyncAopServiceImpl$$EnhancerBySpringCGLIB$$9de92f4b //可以看出来是CGLB动态代理\n------>当前对象：class com.minuor.aop.impl.AsyncAopServiceImpl\n```\n\n**@Transactional注解失效的原因分析**\n\n这个原因和上面的是相同的，代理被绕过，直接当前对象执行应该被增强的方法，导致方法没有被增强成功。但是可以说一下两个情况。\n\n情况一：在非代理增强方法中调用加了`@Transactional`增强的方法\n这个过程容易理解，不解释。\n\n业务代码\n\n``` java\n@Service\npublic class TransactionalAopServiceImpl implements TransactionalAopService {\n\n   @Autowired\n   private OrderDao orderDao;\n   @Autowired\n   private UserDao userDao;\n\n   public void addOrder() {\n       orderDao.insert(OrderModel.builder()\n               .userId(\"YK_002\") //游客编号\n               .phone(\"13522203330\")\n               .orderId(\"ORDER_2018042602\")\n               .amount(10000L)\n               .build());\n       //默开用户\n       System.out.println(\"--->\"+this.getClass());\n       addUser(\"13522203330\");\n   }\n\n   @Transactional\n   public void addUser(String phone) {\n       userDao.insert(UserModel.builder().userName(\"zhangsan\").userPhone(phone).build());\n       throw new RuntimeException();\n   }\n}\n```\n\n运行结果是order订单信息添加成功，同时user用户信息也添加成功，数据库都有数据，没有回滚。按照表面理解应该是order添加成功，user添加失败，因为addUser上加了事务，会回滚。原理参照@Async失效的原理解释。\n\n**情况二：addOrder和addUser方法上都添加@Transactional**\n\n这种情况下，是可以回滚的，但是不太清楚是在哪个事务回滚，也不太清楚`@Transactional`是都有效，还是其中一个有效。但是可以模拟，那就是定义三个异常，分别是`OrderException`、`UserException`、`OtherException`，然后在两个方法上指定回滚异常类。通过抛出不同的异常来看具体的结果。\n\n`@Transactional`修改\n``` java\n@Transactional(rollbackFor = OrderException.class, noRollbackFor = RuntimeException.class) \n//addOrder方法上\n@Transactional(rollbackFor = UserException.class, noRollbackFor = RuntimeException.class) \n//addUser方法上\n```\n\n**执行结果分析**\n\n1、抛`OtherException`异常，没有回滚，`order`、`user`数据都成功录入到数据库中；\n2、抛`UserException`异常，没有回滚，`order`、`user`数据都成功录入到数据库中，这里可以看的出来`addUser`方法上的`@Transactional`注解是无效的；\n3、抛`OrderException`异常，回滚成功，`order`、`user`数据都没有录入到数据库中，`addOrder`方法上的`@Transactional`有效。\n\n这样的结果加上动态代理原理的分析不难得出结果，`addUser`方法的代理增强被绕过，只是普通的一个方法调用，而且这个方法是包含在`addOrder`方法事务内的。\n\n","source":"_posts/Spring注解-Async和-Transactional失效问题究竟是什么原因，强势解释一波.md","raw":"---\ntitle: Spring注解@Async和@Transactional失效问题究竟是什么原因，强势解释一波\ndate: 2017-07-01 21:53:39\ncomments: false\ntags:\n    - java\n    - spring\ncategories:\n    - 学习笔记\n    - java学习笔记\n---\n\n## 提前说说\n\n项目中涉及到的代码我都会上传到码云(gitee)或者github上，提供给大家下载参考，文中就以最简单的方式说明执行过程。源码的地址在文末哦！\n\n\n\n## 问题场景重现\n\n**场景一：**\n\nSpring的异步执行注解@Async，在调用这个方法的时候发现，不对劲，耗时的逻辑我已经加入到异步取做了，怎么接口请求的响应这么慢，赶紧看日志，懵X，加了异步注解，却没有异步执行。\n\n**场景二：**\n\n在项目中用到@Transactional注解实现事务是必须滴，如果你还在用xml配置，那我只能说……。\n\n但是有时候我们会发现在方法上加了@Transactional注解却出现灵异事件，在方法内出现异常，数据还是插入到数据库，没有回滚，事务哪里去了，明明是加了的。\n\n**@Async注解实现原因分析和解决方案**\n\n在看下面的内容之前，对动态代理不是很熟悉的可以看一下我之前的一篇文章：[http://blog.zdydoit.com/blogs/2018/06/dynamic-static-proxy/](http://blog.zdydoit.com/blogs/2018/06/dynamic-static-proxy/)。\n这里添加的注解是通过Spring AOP对方法的一种增强，而Spring AOP的原理就是动态代理，他的代理有两种，分别是CGLB和JDK自带的代理，Spring AOP会根据具体的实现不同，采用不同的代理方式。\n动态代理的原理了解了，下面的问题就可以很好的理解。\n\n**异步测试接口**\n\n\n``` java\npublic interface AsyncAopService {\n   void addOrder();\n   void sendMsg(int result);\n}\n```\n\n**异步测试接口实现**\n``` java\n@Service\n@Slf4j\npublic class AsyncAopServiceImpl implements AsyncAopService {\n\n   @Autowired\n   private OrderDao orderDao;\n   @Autowired\n   private MsgDao msgDao;\n\n   /**\n    * 添加订单后会给用户异步的推送信息\n    */\n   @Transactional //这里为了让该被代理，加此注解\n   public void addOrder() {\n       int result = orderDao.insert(OrderModel.builder()\n               .amount(10000L)\n               .orderId(\"ORDER_2018042601\")\n               .phone(\"15600001212\")\n               .userId(\"U_001\")\n               .build());\n       String currentThreadName = Thread.currentThread().getName();\n       sendMsg(result);\n       System.out.println(currentThreadName + \"------>下单结束：mark\");\n   }\n\n   @Async\n   public void sendMsg(int result) {\n       try {\n           Thread thread = Thread.currentThread();\n           thread.sleep(3000);//停留3秒\n           String currentThreadName = thread.getName();\n           if (result == 1) {\n               msgDao.insert(MsgModel.builder().msgContent(\"下单成功！\").receiver(\"15600001212\").build());\n               System.out.println(currentThreadName + \"------>发送信息成功\");\n           } else {\n               msgDao.insert(MsgModel.builder().msgContent(\"下单失败！\").receiver(\"15600001212\").build());\n               System.out.println(currentThreadName + \"------>发送信息失败\");\n           }\n       } catch (Exception e) {\n           e.printStackTrace();\n       }\n   }\n}\n```\n\n**测试类**\n``` java\n@Test\npublic void AsyncTest() throws InterruptedException {\n System.out.println(\"=======async test start=======\");\n asyncAopService.addOrder();\n System.out.println(\"=======async test end=======\");\n /**\n  * 在这里让线程睡5秒的原因是为了能够看到异步执行的结果日志\n  * 小知识点：在Junit测试中，如果主线程执行结束，\n  *整个测试过程也结束了，存在的异步逻辑如果没有执行完就不会执行啦!\n  * 测试方式：把这行代码去掉，执行测试，t_order_info表中会插入数据，\n  *但是t_msg_info表中无数据插入。\n  */\n Thread.sleep(5000);\n}\n```\n\n**测试类上的注解：**\n``` java\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n```\n\n**Spring Boot启动类的注解：**\n``` java\n@SpringBootApplication\n@MapperScan(\"com.minuor.aop.dao\")\n@EnableAspectJAutoProxy\n@EnableAsync //开启异步功能\n```\n\n**测试结果**\n``` java\n=======async test start=======\nmain------>发送信息成功\nmain------>下单结束：mark\n=======async test end=======\n```\n\n运行的过程很慢，两行日志的线程名称相同，并且mark日志是在发送信息成功后再输出的，回到代码可以知道发送信息逻辑是异步的执行，为什么会和下单过程的线程名称相同，并且异步执行发送消息是延迟的，为何日志还在mark日志前。种种迹象表明，这不是一个异步执行，而是顺序执行。但是这里是加了异步的注解的，实际没有生效。\n在`addOrder()`方法里面直接调用`sendMsg(……)`方法，这里还隐含一个关键字，那就是`this`，实际上这里调用是这样的：`this.sendMsg()`,`this`是当前对象。而`addOrder()`是被代理的，在代理对象中执行结束增强后，通过`invoke`，用实际`AsyncAopServiceImpl`对象来调用`addOrder()`方法执行业务逻辑。在业务逻辑内又调用了`sendMsg(……)`方法，调用的对象是当前对象，当前对象是`AsyncAopServiceImpl`，问题就出在这里，因为要想用异步执行`sendMsg(……)`，必须用代理对象执行，因为代理对象要做异步相关的增强，但是此时却直接用AsyncAopServiceImpl对象调用，绕过了代理对象增强的部分，也就是说代理增强部分失效，`@Async`注解失效。原来想异步执行的逻辑，变成了顺序执行。\n\n**解决方案**\n\n没有用代理对象执行`sendMsg(……)`，被`AsyncAopServiceImpl`对象抢占了先机。那么解决就是要让代理对象来执行`sendMsg(……)`。\n在调用`sendMsg(……)`之前添加下面的代码\n\n``` java\nAsyncAopService service = (AsyncAopService) AopContext.currentProxy(); \n//获取代理对象\nservice.sendMsg(result); \n//通过代理对象调用sendMsg，做异步增强\n```\n这里还不算完，如果就这样运行，那肯定会报错。\n**在@EnableAspectJAutoProxy添加属性值。**\n> @EnableAspectJAutoProxy(exposeProxy = true)\n\n运行结果\n``` java\n=======async test start=======\nmain------>下单结束：mark\n=======async test end=======\nSimpleAsyncTaskExecutor-1------>发送信息成功\n```\n\n结果也是想要的结果，下单结束，整个测试结束，在测试结束后等待5秒，等待异步日志打印。主线程和异步线程是不同的两个。\n\n如果对代理对象和当前对象有点懵的话，可以加上下面的两行代码\n``` java\nSystem.out.println(\"------>代理对象：\"+service.getClass());\nSystem.out.println(\"------>当前对象：\"+this.getClass());\n```\n得到的结果：\n``` java\n------>代理对象：class com.minuor.aop.impl.AsyncAopServiceImpl$$EnhancerBySpringCGLIB$$9de92f4b //可以看出来是CGLB动态代理\n------>当前对象：class com.minuor.aop.impl.AsyncAopServiceImpl\n```\n\n**@Transactional注解失效的原因分析**\n\n这个原因和上面的是相同的，代理被绕过，直接当前对象执行应该被增强的方法，导致方法没有被增强成功。但是可以说一下两个情况。\n\n情况一：在非代理增强方法中调用加了`@Transactional`增强的方法\n这个过程容易理解，不解释。\n\n业务代码\n\n``` java\n@Service\npublic class TransactionalAopServiceImpl implements TransactionalAopService {\n\n   @Autowired\n   private OrderDao orderDao;\n   @Autowired\n   private UserDao userDao;\n\n   public void addOrder() {\n       orderDao.insert(OrderModel.builder()\n               .userId(\"YK_002\") //游客编号\n               .phone(\"13522203330\")\n               .orderId(\"ORDER_2018042602\")\n               .amount(10000L)\n               .build());\n       //默开用户\n       System.out.println(\"--->\"+this.getClass());\n       addUser(\"13522203330\");\n   }\n\n   @Transactional\n   public void addUser(String phone) {\n       userDao.insert(UserModel.builder().userName(\"zhangsan\").userPhone(phone).build());\n       throw new RuntimeException();\n   }\n}\n```\n\n运行结果是order订单信息添加成功，同时user用户信息也添加成功，数据库都有数据，没有回滚。按照表面理解应该是order添加成功，user添加失败，因为addUser上加了事务，会回滚。原理参照@Async失效的原理解释。\n\n**情况二：addOrder和addUser方法上都添加@Transactional**\n\n这种情况下，是可以回滚的，但是不太清楚是在哪个事务回滚，也不太清楚`@Transactional`是都有效，还是其中一个有效。但是可以模拟，那就是定义三个异常，分别是`OrderException`、`UserException`、`OtherException`，然后在两个方法上指定回滚异常类。通过抛出不同的异常来看具体的结果。\n\n`@Transactional`修改\n``` java\n@Transactional(rollbackFor = OrderException.class, noRollbackFor = RuntimeException.class) \n//addOrder方法上\n@Transactional(rollbackFor = UserException.class, noRollbackFor = RuntimeException.class) \n//addUser方法上\n```\n\n**执行结果分析**\n\n1、抛`OtherException`异常，没有回滚，`order`、`user`数据都成功录入到数据库中；\n2、抛`UserException`异常，没有回滚，`order`、`user`数据都成功录入到数据库中，这里可以看的出来`addUser`方法上的`@Transactional`注解是无效的；\n3、抛`OrderException`异常，回滚成功，`order`、`user`数据都没有录入到数据库中，`addOrder`方法上的`@Transactional`有效。\n\n这样的结果加上动态代理原理的分析不难得出结果，`addUser`方法的代理增强被绕过，只是普通的一个方法调用，而且这个方法是包含在`addOrder`方法事务内的。\n\n","slug":"Spring注解-Async和-Transactional失效问题究竟是什么原因，强势解释一波","published":1,"updated":"2018-07-10T07:59:45.591Z","layout":"post","photos":[],"link":"","_id":"cjjfplfjs000vcwp6m4nr47ak","content":"<h2><span id=\"提前说说\">提前说说</span></h2><p>项目中涉及到的代码我都会上传到码云(gitee)或者github上，提供给大家下载参考，文中就以最简单的方式说明执行过程。源码的地址在文末哦！</p>\n<h2><span id=\"问题场景重现\">问题场景重现</span></h2><p><strong>场景一：</strong></p>\n<p>Spring的异步执行注解@Async，在调用这个方法的时候发现，不对劲，耗时的逻辑我已经加入到异步取做了，怎么接口请求的响应这么慢，赶紧看日志，懵X，加了异步注解，却没有异步执行。</p>\n<p><strong>场景二：</strong></p>\n<p>在项目中用到@Transactional注解实现事务是必须滴，如果你还在用xml配置，那我只能说……。</p>\n<p>但是有时候我们会发现在方法上加了@Transactional注解却出现灵异事件，在方法内出现异常，数据还是插入到数据库，没有回滚，事务哪里去了，明明是加了的。</p>\n<p><strong>@Async注解实现原因分析和解决方案</strong></p>\n<p>在看下面的内容之前，对动态代理不是很熟悉的可以看一下我之前的一篇文章：<a href=\"http://blog.zdydoit.com/blogs/2018/06/dynamic-static-proxy/\" target=\"_blank\" rel=\"noopener\">http://blog.zdydoit.com/blogs/2018/06/dynamic-static-proxy/</a>。<br>这里添加的注解是通过Spring AOP对方法的一种增强，而Spring AOP的原理就是动态代理，他的代理有两种，分别是CGLB和JDK自带的代理，Spring AOP会根据具体的实现不同，采用不同的代理方式。<br>动态代理的原理了解了，下面的问题就可以很好的理解。</p>\n<p><strong>异步测试接口</strong></p>\n<pre><code class=\"java\">public interface AsyncAopService {\n   void addOrder();\n   void sendMsg(int result);\n}\n</code></pre>\n<p><strong>异步测试接口实现</strong></p>\n<pre><code class=\"java\">@Service\n@Slf4j\npublic class AsyncAopServiceImpl implements AsyncAopService {\n\n   @Autowired\n   private OrderDao orderDao;\n   @Autowired\n   private MsgDao msgDao;\n\n   /**\n    * 添加订单后会给用户异步的推送信息\n    */\n   @Transactional //这里为了让该被代理，加此注解\n   public void addOrder() {\n       int result = orderDao.insert(OrderModel.builder()\n               .amount(10000L)\n               .orderId(&quot;ORDER_2018042601&quot;)\n               .phone(&quot;15600001212&quot;)\n               .userId(&quot;U_001&quot;)\n               .build());\n       String currentThreadName = Thread.currentThread().getName();\n       sendMsg(result);\n       System.out.println(currentThreadName + &quot;------&gt;下单结束：mark&quot;);\n   }\n\n   @Async\n   public void sendMsg(int result) {\n       try {\n           Thread thread = Thread.currentThread();\n           thread.sleep(3000);//停留3秒\n           String currentThreadName = thread.getName();\n           if (result == 1) {\n               msgDao.insert(MsgModel.builder().msgContent(&quot;下单成功！&quot;).receiver(&quot;15600001212&quot;).build());\n               System.out.println(currentThreadName + &quot;------&gt;发送信息成功&quot;);\n           } else {\n               msgDao.insert(MsgModel.builder().msgContent(&quot;下单失败！&quot;).receiver(&quot;15600001212&quot;).build());\n               System.out.println(currentThreadName + &quot;------&gt;发送信息失败&quot;);\n           }\n       } catch (Exception e) {\n           e.printStackTrace();\n       }\n   }\n}\n</code></pre>\n<p><strong>测试类</strong></p>\n<pre><code class=\"java\">@Test\npublic void AsyncTest() throws InterruptedException {\n System.out.println(&quot;=======async test start=======&quot;);\n asyncAopService.addOrder();\n System.out.println(&quot;=======async test end=======&quot;);\n /**\n  * 在这里让线程睡5秒的原因是为了能够看到异步执行的结果日志\n  * 小知识点：在Junit测试中，如果主线程执行结束，\n  *整个测试过程也结束了，存在的异步逻辑如果没有执行完就不会执行啦!\n  * 测试方式：把这行代码去掉，执行测试，t_order_info表中会插入数据，\n  *但是t_msg_info表中无数据插入。\n  */\n Thread.sleep(5000);\n}\n</code></pre>\n<p><strong>测试类上的注解：</strong></p>\n<pre><code class=\"java\">@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n</code></pre>\n<p><strong>Spring Boot启动类的注解：</strong></p>\n<pre><code class=\"java\">@SpringBootApplication\n@MapperScan(&quot;com.minuor.aop.dao&quot;)\n@EnableAspectJAutoProxy\n@EnableAsync //开启异步功能\n</code></pre>\n<p><strong>测试结果</strong></p>\n<pre><code class=\"java\">=======async test start=======\nmain------&gt;发送信息成功\nmain------&gt;下单结束：mark\n=======async test end=======\n</code></pre>\n<p>运行的过程很慢，两行日志的线程名称相同，并且mark日志是在发送信息成功后再输出的，回到代码可以知道发送信息逻辑是异步的执行，为什么会和下单过程的线程名称相同，并且异步执行发送消息是延迟的，为何日志还在mark日志前。种种迹象表明，这不是一个异步执行，而是顺序执行。但是这里是加了异步的注解的，实际没有生效。<br>在<code>addOrder()</code>方法里面直接调用<code>sendMsg(……)</code>方法，这里还隐含一个关键字，那就是<code>this</code>，实际上这里调用是这样的：<code>this.sendMsg()</code>,<code>this</code>是当前对象。而<code>addOrder()</code>是被代理的，在代理对象中执行结束增强后，通过<code>invoke</code>，用实际<code>AsyncAopServiceImpl</code>对象来调用<code>addOrder()</code>方法执行业务逻辑。在业务逻辑内又调用了<code>sendMsg(……)</code>方法，调用的对象是当前对象，当前对象是<code>AsyncAopServiceImpl</code>，问题就出在这里，因为要想用异步执行<code>sendMsg(……)</code>，必须用代理对象执行，因为代理对象要做异步相关的增强，但是此时却直接用AsyncAopServiceImpl对象调用，绕过了代理对象增强的部分，也就是说代理增强部分失效，<code>@Async</code>注解失效。原来想异步执行的逻辑，变成了顺序执行。</p>\n<p><strong>解决方案</strong></p>\n<p>没有用代理对象执行<code>sendMsg(……)</code>，被<code>AsyncAopServiceImpl</code>对象抢占了先机。那么解决就是要让代理对象来执行<code>sendMsg(……)</code>。<br>在调用<code>sendMsg(……)</code>之前添加下面的代码</p>\n<pre><code class=\"java\">AsyncAopService service = (AsyncAopService) AopContext.currentProxy(); \n//获取代理对象\nservice.sendMsg(result); \n//通过代理对象调用sendMsg，做异步增强\n</code></pre>\n<p>这里还不算完，如果就这样运行，那肯定会报错。<br><strong>在@EnableAspectJAutoProxy添加属性值。</strong></p>\n<blockquote>\n<p>@EnableAspectJAutoProxy(exposeProxy = true)</p>\n</blockquote>\n<p>运行结果</p>\n<pre><code class=\"java\">=======async test start=======\nmain------&gt;下单结束：mark\n=======async test end=======\nSimpleAsyncTaskExecutor-1------&gt;发送信息成功\n</code></pre>\n<p>结果也是想要的结果，下单结束，整个测试结束，在测试结束后等待5秒，等待异步日志打印。主线程和异步线程是不同的两个。</p>\n<p>如果对代理对象和当前对象有点懵的话，可以加上下面的两行代码</p>\n<pre><code class=\"java\">System.out.println(&quot;------&gt;代理对象：&quot;+service.getClass());\nSystem.out.println(&quot;------&gt;当前对象：&quot;+this.getClass());\n</code></pre>\n<p>得到的结果：</p>\n<pre><code class=\"java\">------&gt;代理对象：class com.minuor.aop.impl.AsyncAopServiceImpl$$EnhancerBySpringCGLIB$$9de92f4b //可以看出来是CGLB动态代理\n------&gt;当前对象：class com.minuor.aop.impl.AsyncAopServiceImpl\n</code></pre>\n<p><strong>@Transactional注解失效的原因分析</strong></p>\n<p>这个原因和上面的是相同的，代理被绕过，直接当前对象执行应该被增强的方法，导致方法没有被增强成功。但是可以说一下两个情况。</p>\n<p>情况一：在非代理增强方法中调用加了<code>@Transactional</code>增强的方法<br>这个过程容易理解，不解释。</p>\n<p>业务代码</p>\n<pre><code class=\"java\">@Service\npublic class TransactionalAopServiceImpl implements TransactionalAopService {\n\n   @Autowired\n   private OrderDao orderDao;\n   @Autowired\n   private UserDao userDao;\n\n   public void addOrder() {\n       orderDao.insert(OrderModel.builder()\n               .userId(&quot;YK_002&quot;) //游客编号\n               .phone(&quot;13522203330&quot;)\n               .orderId(&quot;ORDER_2018042602&quot;)\n               .amount(10000L)\n               .build());\n       //默开用户\n       System.out.println(&quot;---&gt;&quot;+this.getClass());\n       addUser(&quot;13522203330&quot;);\n   }\n\n   @Transactional\n   public void addUser(String phone) {\n       userDao.insert(UserModel.builder().userName(&quot;zhangsan&quot;).userPhone(phone).build());\n       throw new RuntimeException();\n   }\n}\n</code></pre>\n<p>运行结果是order订单信息添加成功，同时user用户信息也添加成功，数据库都有数据，没有回滚。按照表面理解应该是order添加成功，user添加失败，因为addUser上加了事务，会回滚。原理参照@Async失效的原理解释。</p>\n<p><strong>情况二：addOrder和addUser方法上都添加@Transactional</strong></p>\n<p>这种情况下，是可以回滚的，但是不太清楚是在哪个事务回滚，也不太清楚<code>@Transactional</code>是都有效，还是其中一个有效。但是可以模拟，那就是定义三个异常，分别是<code>OrderException</code>、<code>UserException</code>、<code>OtherException</code>，然后在两个方法上指定回滚异常类。通过抛出不同的异常来看具体的结果。</p>\n<p><code>@Transactional</code>修改</p>\n<pre><code class=\"java\">@Transactional(rollbackFor = OrderException.class, noRollbackFor = RuntimeException.class) \n//addOrder方法上\n@Transactional(rollbackFor = UserException.class, noRollbackFor = RuntimeException.class) \n//addUser方法上\n</code></pre>\n<p><strong>执行结果分析</strong></p>\n<p>1、抛<code>OtherException</code>异常，没有回滚，<code>order</code>、<code>user</code>数据都成功录入到数据库中；<br>2、抛<code>UserException</code>异常，没有回滚，<code>order</code>、<code>user</code>数据都成功录入到数据库中，这里可以看的出来<code>addUser</code>方法上的<code>@Transactional</code>注解是无效的；<br>3、抛<code>OrderException</code>异常，回滚成功，<code>order</code>、<code>user</code>数据都没有录入到数据库中，<code>addOrder</code>方法上的<code>@Transactional</code>有效。</p>\n<p>这样的结果加上动态代理原理的分析不难得出结果，<code>addUser</code>方法的代理增强被绕过，只是普通的一个方法调用，而且这个方法是包含在<code>addOrder</code>方法事务内的。</p>\n","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":"<h2 id=\"提前说说\"><a href=\"#提前说说\" class=\"headerlink\" title=\"提前说说\"></a>提前说说</h2><p>项目中涉及到的代码我都会上传到码云(gitee)或者github上，提供给大家下载参考，文中就以最简单的方式说明执行过程。源码的地址在文末哦！</p>\n<h2 id=\"问题场景重现\"><a href=\"#问题场景重现\" class=\"headerlink\" title=\"问题场景重现\"></a>问题场景重现</h2><p><strong>场景一：</strong></p>\n<p>Spring的异步执行注解@Async，在调用这个方法的时候发现，不对劲，耗时的逻辑我已经加入到异步取做了，怎么接口请求的响应这么慢，赶紧看日志，懵X，加了异步注解，却没有异步执行。</p>\n<p><strong>场景二：</strong></p>\n<p>在项目中用到@Transactional注解实现事务是必须滴，如果你还在用xml配置，那我只能说……。</p>\n<p>但是有时候我们会发现在方法上加了@Transactional注解却出现灵异事件，在方法内出现异常，数据还是插入到数据库，没有回滚，事务哪里去了，明明是加了的。</p>\n<p><strong>@Async注解实现原因分析和解决方案</strong></p>\n<p>在看下面的内容之前，对动态代理不是很熟悉的可以看一下我之前的一篇文章：<a href=\"http://blog.zdydoit.com/blogs/2018/06/dynamic-static-proxy/\" target=\"_blank\" rel=\"noopener\">http://blog.zdydoit.com/blogs/2018/06/dynamic-static-proxy/</a>。<br>这里添加的注解是通过Spring AOP对方法的一种增强，而Spring AOP的原理就是动态代理，他的代理有两种，分别是CGLB和JDK自带的代理，Spring AOP会根据具体的实现不同，采用不同的代理方式。<br>动态代理的原理了解了，下面的问题就可以很好的理解。</p>\n<p><strong>异步测试接口</strong></p>\n<pre><code class=\"java\">public interface AsyncAopService {\n   void addOrder();\n   void sendMsg(int result);\n}\n</code></pre>\n<p><strong>异步测试接口实现</strong></p>\n<pre><code class=\"java\">@Service\n@Slf4j\npublic class AsyncAopServiceImpl implements AsyncAopService {\n\n   @Autowired\n   private OrderDao orderDao;\n   @Autowired\n   private MsgDao msgDao;\n\n   /**\n    * 添加订单后会给用户异步的推送信息\n    */\n   @Transactional //这里为了让该被代理，加此注解\n   public void addOrder() {\n       int result = orderDao.insert(OrderModel.builder()\n               .amount(10000L)\n               .orderId(&quot;ORDER_2018042601&quot;)\n               .phone(&quot;15600001212&quot;)\n               .userId(&quot;U_001&quot;)\n               .build());\n       String currentThreadName = Thread.currentThread().getName();\n       sendMsg(result);\n       System.out.println(currentThreadName + &quot;------&gt;下单结束：mark&quot;);\n   }\n\n   @Async\n   public void sendMsg(int result) {\n       try {\n           Thread thread = Thread.currentThread();\n           thread.sleep(3000);//停留3秒\n           String currentThreadName = thread.getName();\n           if (result == 1) {\n               msgDao.insert(MsgModel.builder().msgContent(&quot;下单成功！&quot;).receiver(&quot;15600001212&quot;).build());\n               System.out.println(currentThreadName + &quot;------&gt;发送信息成功&quot;);\n           } else {\n               msgDao.insert(MsgModel.builder().msgContent(&quot;下单失败！&quot;).receiver(&quot;15600001212&quot;).build());\n               System.out.println(currentThreadName + &quot;------&gt;发送信息失败&quot;);\n           }\n       } catch (Exception e) {\n           e.printStackTrace();\n       }\n   }\n}\n</code></pre>\n<p><strong>测试类</strong></p>\n<pre><code class=\"java\">@Test\npublic void AsyncTest() throws InterruptedException {\n System.out.println(&quot;=======async test start=======&quot;);\n asyncAopService.addOrder();\n System.out.println(&quot;=======async test end=======&quot;);\n /**\n  * 在这里让线程睡5秒的原因是为了能够看到异步执行的结果日志\n  * 小知识点：在Junit测试中，如果主线程执行结束，\n  *整个测试过程也结束了，存在的异步逻辑如果没有执行完就不会执行啦!\n  * 测试方式：把这行代码去掉，执行测试，t_order_info表中会插入数据，\n  *但是t_msg_info表中无数据插入。\n  */\n Thread.sleep(5000);\n}\n</code></pre>\n<p><strong>测试类上的注解：</strong></p>\n<pre><code class=\"java\">@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n</code></pre>\n<p><strong>Spring Boot启动类的注解：</strong></p>\n<pre><code class=\"java\">@SpringBootApplication\n@MapperScan(&quot;com.minuor.aop.dao&quot;)\n@EnableAspectJAutoProxy\n@EnableAsync //开启异步功能\n</code></pre>\n<p><strong>测试结果</strong></p>\n<pre><code class=\"java\">=======async test start=======\nmain------&gt;发送信息成功\nmain------&gt;下单结束：mark\n=======async test end=======\n</code></pre>\n<p>运行的过程很慢，两行日志的线程名称相同，并且mark日志是在发送信息成功后再输出的，回到代码可以知道发送信息逻辑是异步的执行，为什么会和下单过程的线程名称相同，并且异步执行发送消息是延迟的，为何日志还在mark日志前。种种迹象表明，这不是一个异步执行，而是顺序执行。但是这里是加了异步的注解的，实际没有生效。<br>在<code>addOrder()</code>方法里面直接调用<code>sendMsg(……)</code>方法，这里还隐含一个关键字，那就是<code>this</code>，实际上这里调用是这样的：<code>this.sendMsg()</code>,<code>this</code>是当前对象。而<code>addOrder()</code>是被代理的，在代理对象中执行结束增强后，通过<code>invoke</code>，用实际<code>AsyncAopServiceImpl</code>对象来调用<code>addOrder()</code>方法执行业务逻辑。在业务逻辑内又调用了<code>sendMsg(……)</code>方法，调用的对象是当前对象，当前对象是<code>AsyncAopServiceImpl</code>，问题就出在这里，因为要想用异步执行<code>sendMsg(……)</code>，必须用代理对象执行，因为代理对象要做异步相关的增强，但是此时却直接用AsyncAopServiceImpl对象调用，绕过了代理对象增强的部分，也就是说代理增强部分失效，<code>@Async</code>注解失效。原来想异步执行的逻辑，变成了顺序执行。</p>\n<p><strong>解决方案</strong></p>\n<p>没有用代理对象执行<code>sendMsg(……)</code>，被<code>AsyncAopServiceImpl</code>对象抢占了先机。那么解决就是要让代理对象来执行<code>sendMsg(……)</code>。<br>在调用<code>sendMsg(……)</code>之前添加下面的代码</p>\n<pre><code class=\"java\">AsyncAopService service = (AsyncAopService) AopContext.currentProxy(); \n//获取代理对象\nservice.sendMsg(result); \n//通过代理对象调用sendMsg，做异步增强\n</code></pre>\n<p>这里还不算完，如果就这样运行，那肯定会报错。<br><strong>在@EnableAspectJAutoProxy添加属性值。</strong></p>\n<blockquote>\n<p>@EnableAspectJAutoProxy(exposeProxy = true)</p>\n</blockquote>\n<p>运行结果</p>\n<pre><code class=\"java\">=======async test start=======\nmain------&gt;下单结束：mark\n=======async test end=======\nSimpleAsyncTaskExecutor-1------&gt;发送信息成功\n</code></pre>\n<p>结果也是想要的结果，下单结束，整个测试结束，在测试结束后等待5秒，等待异步日志打印。主线程和异步线程是不同的两个。</p>\n<p>如果对代理对象和当前对象有点懵的话，可以加上下面的两行代码</p>\n<pre><code class=\"java\">System.out.println(&quot;------&gt;代理对象：&quot;+service.getClass());\nSystem.out.println(&quot;------&gt;当前对象：&quot;+this.getClass());\n</code></pre>\n<p>得到的结果：</p>\n<pre><code class=\"java\">------&gt;代理对象：class com.minuor.aop.impl.AsyncAopServiceImpl$$EnhancerBySpringCGLIB$$9de92f4b //可以看出来是CGLB动态代理\n------&gt;当前对象：class com.minuor.aop.impl.AsyncAopServiceImpl\n</code></pre>\n<p><strong>@Transactional注解失效的原因分析</strong></p>\n<p>这个原因和上面的是相同的，代理被绕过，直接当前对象执行应该被增强的方法，导致方法没有被增强成功。但是可以说一下两个情况。</p>\n<p>情况一：在非代理增强方法中调用加了<code>@Transactional</code>增强的方法<br>这个过程容易理解，不解释。</p>\n<p>业务代码</p>\n<pre><code class=\"java\">@Service\npublic class TransactionalAopServiceImpl implements TransactionalAopService {\n\n   @Autowired\n   private OrderDao orderDao;\n   @Autowired\n   private UserDao userDao;\n\n   public void addOrder() {\n       orderDao.insert(OrderModel.builder()\n               .userId(&quot;YK_002&quot;) //游客编号\n               .phone(&quot;13522203330&quot;)\n               .orderId(&quot;ORDER_2018042602&quot;)\n               .amount(10000L)\n               .build());\n       //默开用户\n       System.out.println(&quot;---&gt;&quot;+this.getClass());\n       addUser(&quot;13522203330&quot;);\n   }\n\n   @Transactional\n   public void addUser(String phone) {\n       userDao.insert(UserModel.builder().userName(&quot;zhangsan&quot;).userPhone(phone).build());\n       throw new RuntimeException();\n   }\n}\n</code></pre>\n<p>运行结果是order订单信息添加成功，同时user用户信息也添加成功，数据库都有数据，没有回滚。按照表面理解应该是order添加成功，user添加失败，因为addUser上加了事务，会回滚。原理参照@Async失效的原理解释。</p>\n<p><strong>情况二：addOrder和addUser方法上都添加@Transactional</strong></p>\n<p>这种情况下，是可以回滚的，但是不太清楚是在哪个事务回滚，也不太清楚<code>@Transactional</code>是都有效，还是其中一个有效。但是可以模拟，那就是定义三个异常，分别是<code>OrderException</code>、<code>UserException</code>、<code>OtherException</code>，然后在两个方法上指定回滚异常类。通过抛出不同的异常来看具体的结果。</p>\n<p><code>@Transactional</code>修改</p>\n<pre><code class=\"java\">@Transactional(rollbackFor = OrderException.class, noRollbackFor = RuntimeException.class) \n//addOrder方法上\n@Transactional(rollbackFor = UserException.class, noRollbackFor = RuntimeException.class) \n//addUser方法上\n</code></pre>\n<p><strong>执行结果分析</strong></p>\n<p>1、抛<code>OtherException</code>异常，没有回滚，<code>order</code>、<code>user</code>数据都成功录入到数据库中；<br>2、抛<code>UserException</code>异常，没有回滚，<code>order</code>、<code>user</code>数据都成功录入到数据库中，这里可以看的出来<code>addUser</code>方法上的<code>@Transactional</code>注解是无效的；<br>3、抛<code>OrderException</code>异常，回滚成功，<code>order</code>、<code>user</code>数据都没有录入到数据库中，<code>addOrder</code>方法上的<code>@Transactional</code>有效。</p>\n<p>这样的结果加上动态代理原理的分析不难得出结果，<code>addUser</code>方法的代理增强被绕过，只是普通的一个方法调用，而且这个方法是包含在<code>addOrder</code>方法事务内的。</p>\n"},{"title":"分布式-Dubbo-架构设计详解","date":"2017-06-29T12:39:01.000Z","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1530122306580&di=e1d46e945e3f24b9b3eaac91a519bf9c&imgtype=0&src=http%3A%2F%2Fb.hiphotos.baidu.com%2Fzhidao%2Fwh%3D450%2C600%2Fsign%3D8090580631c79f3d8fb4ec348f91e127%2Fa2cc7cd98d1001e970ac09f6b20e7bec55e797b2.jpg","_content":"\nDubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。关于注册中心、协议支持、服务监控等内容，详见后面描述。\n\n[总体架构](http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247484330&idx=1&sn=30f9cbb95821d06a3a5884edd8f1cb4f&chksm=eb53869cdc240f8a237b975ec7f51817c020cfaacfaf48c6ac8a7bb9ca3516ee39db1847dfdf&scene=21#wechat_redirect)\n\nDubbo的总体架构，如图所示：\n![Dubbo的总体架构](https://img.szpinc.org/2018-06-27-1529978103556108.jpg)\n\nDubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。点击这里可以了解更多架构设计图。\n\n\n\n下面，结合Dubbo官方文档，我们分别理解一下框架分层架构中，各个层次的设计要点：\n1. 服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。    \n2. 配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。\n3. 服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。\n4. 服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。    \n5. 集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。    \n6. 监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。    \n7. 远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。    \n8. 信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。    \n9. 网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。    \n10. 数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。\n\n从上图可以看出，Dubbo对于服务提供方和服务消费方，从框架的10层中分别提供了各自需要关心和扩展的接口，构建整个服务生态系统（服务提供方和服务消费方本身就是一个以服务为中心的）。\n\n**根据官方提供的，对于上述各层之间关系的描述，如下所示：**\n\n* 在RPC中，Protocol是核心层，也就是只要有Protocol + Invoker + Exporter就可以完成非透明的RPC调用，然后在Invoker的主过程上Filter拦截点。\n* 图中的Consumer和Provider是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用Client和Server的原因是Dubbo在很多场景下都使用Provider、Consumer、Registry、Monitor划分逻辑拓普节点，保持统一概念。\n* 而Cluster是外围概念，所以Cluster的目的是将多个Invoker伪装成一个Invoker，这样其它人只要关注Protocol层Invoker即可，加上Cluster或者去掉Cluster对其它层都不会造成影响，因为只有一个提供者时，是不需要Cluster的。    \n* Proxy层封装了所有接口的透明化代理，而在其它层都以Invoker为中心，只有到了暴露给用户使用时，才用Proxy将Invoker转成接口，或将接口实现转成Invoker，也就是去掉Proxy层RPC是可以Run的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。    \n* 而Remoting实现是Dubbo协议的实现，如果你选择RMI协议，整个Remoting都不会用上，Remoting内部再划为Transport传输层和Exchange信息交换层，Transport层只负责单向消息传输，是对Mina、Netty、Grizzly的抽象，它也可以扩展UDP传输，而Exchange层是在传输层之上封装了Request-Response语义。    \n* Registry和Monitor实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。\n\n从上面的架构图中，我们可以了解到，Dubbo作为一个分布式服务框架，主要具有如下几个核心的要点：\n\n**服务定义**\n\n服务是围绕服务提供方和服务消费方的，服务提供方实现服务，而服务消费方调用服务。\n\n**服务注册**\n\n对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；对于服务消费方，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。而且，对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。\n\n通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。Dubbo提供的注册中心有如下几种类型可供选择：\n\n* Multicast注册中心\n* Zookeeper注册中心\n* Redis注册中心\n* Simple注册中心\n\n**服务监控**\n\n无论是服务提供方，还是服务消费方，他们都需要对服务调用的实际状态进行有效的监控，从而改进服务质量。\n\n**远程通信与信息交换**\n\n远程通信需要指定通信双方所约定的协议，在保证通信双方理解协议语义的基础上，还要保证高效、稳定的消息传输。Dubbo继承了当前主流的网络通信框架，主要包括如下几个：\n\n* Mina   \n* Netty    \n* Grizzly\n\n**服务调用**\n\n下面从Dubbo官网直接拿来，看一下基于RPC层，服务提供方和服务消费方之间的调用关系，如图所示：\n![1529978103528987](https://img.szpinc.org/2018-06-27-1529978103528987.jpg)\n\n上图中，蓝色的表示与业务有交互，绿色的表示只对Dubbo内部交互。点击这里可以了解更多架构设计图。上述图所描述的调用流程如下：\n\n* 服务提供方发布服务到服务注册中心；    \n* 服务消费方从服务注册中心订阅服务；    \n* 服务消费方调用已经注册的可用服务\n\n接着，将上面抽象的调用流程图展开，详细如图所示：\n![1529978103768057](https://img.szpinc.org/2018-06-27-1529978103768057.jpg)\n\n**注册/注销服务**\n\n服务的注册与注销，是对服务提供方角色而言，那么注册服务与注销服务的时序图，如图所示：\n![Dubbo的总体架构](https://img.szpinc.org/2018-06-27-1529978103556108.jpg)\n![1529978104606612](https://img.szpinc.org/2018-06-27-1529978104606612.jpg)\n\n**服务订阅/取消**\n\n为了满足应用系统的需求，服务消费方的可能需要从服务注册中心订阅指定的有服务提供方发布的服务，在得到通知可以使用服务时，就可以直接调用服务。反过来，如果不需要某一个服务了，可以取消该服务。下面看一下对应的时序图，如图所示：\n\n![1529978104143601](https://img.szpinc.org/2018-06-27-1529978104143601.jpg)\n\n**[协议支持](http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247486211&idx=1&sn=9af18f0057fe72f3507605d6e9519e7e&chksm=eb538e35dc24072323183ff9425885270dd7d8d51d118d86608fe24929e207c3ad7deb879336&scene=21#wechat_redirect)**\n\n* Dubbo协议\n* Hessian协议\n* HTTP协议\n* RMI协议\n* WebService协议\n* Thrift协议\n* Memcached协议\n* Redis协议\n\n在通信过程中，不同的服务等级一般对应着不同的服务质量，那么选择合适的协议便是一件非常重要的事情。你可以根据你应用的创建来选择。例如，使用RMI协议，一般会受到防火墙的限制，所以对于外部与内部进行通信的场景，就不要使用RMI协议，而是基于HTTP协议或者Hessian协议。\n\n参考补充\n\nDubbo以包结构来组织各个模块，各个模块及其关系，如图所示：\n\n![1529978104550711](https://img.szpinc.org/2018-06-27-1529978104550711.jpg)\n\n* 可以通过Dubbo的代码（使用Maven管理）组织，与上面的模块进行比较。简单说明各个包的情况：\n* dubbo-common 公共逻辑模块，包括Util类和通用模型。\n* dubbo-remoting 远程通讯模块，相当于Dubbo协议的实现，如果RPC用RMI协议则不需要使用此包。\n* dubbo-rpc 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。\n* dubbo-cluster 集群模块，将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。\n* dubbo-registry 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。\n* dubbo-monitor 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。\n* dubbo-config 配置模块，是Dubbo对外的API，用户通过Config使用Dubbo，隐藏Dubbo所有细节。\n* dubbo-container 容器模块，是一个Standalone的容器，以简单的Main加载Spring启动，因为服务通常不需要Tomcat/JBoss等Web容器的特性，没必要用Web容器去加载服务。\n\n","source":"_posts/分布式-dubbo-架构设计详解.md","raw":"---\ntitle: 分布式-Dubbo-架构设计详解\ndate: 2017-06-29 20:39:01\nthumbnail: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1530122306580&di=e1d46e945e3f24b9b3eaac91a519bf9c&imgtype=0&src=http%3A%2F%2Fb.hiphotos.baidu.com%2Fzhidao%2Fwh%3D450%2C600%2Fsign%3D8090580631c79f3d8fb4ec348f91e127%2Fa2cc7cd98d1001e970ac09f6b20e7bec55e797b2.jpg\ntags:\n    - java\n    - 微服务\n    - dubbo\ncategories:\n    - java\n    - 学习笔记\n---\n\nDubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。关于注册中心、协议支持、服务监控等内容，详见后面描述。\n\n[总体架构](http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247484330&idx=1&sn=30f9cbb95821d06a3a5884edd8f1cb4f&chksm=eb53869cdc240f8a237b975ec7f51817c020cfaacfaf48c6ac8a7bb9ca3516ee39db1847dfdf&scene=21#wechat_redirect)\n\nDubbo的总体架构，如图所示：\n![Dubbo的总体架构](https://img.szpinc.org/2018-06-27-1529978103556108.jpg)\n\nDubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。点击这里可以了解更多架构设计图。\n\n\n\n下面，结合Dubbo官方文档，我们分别理解一下框架分层架构中，各个层次的设计要点：\n1. 服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。    \n2. 配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。\n3. 服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。\n4. 服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。    \n5. 集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。    \n6. 监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。    \n7. 远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。    \n8. 信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。    \n9. 网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。    \n10. 数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。\n\n从上图可以看出，Dubbo对于服务提供方和服务消费方，从框架的10层中分别提供了各自需要关心和扩展的接口，构建整个服务生态系统（服务提供方和服务消费方本身就是一个以服务为中心的）。\n\n**根据官方提供的，对于上述各层之间关系的描述，如下所示：**\n\n* 在RPC中，Protocol是核心层，也就是只要有Protocol + Invoker + Exporter就可以完成非透明的RPC调用，然后在Invoker的主过程上Filter拦截点。\n* 图中的Consumer和Provider是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用Client和Server的原因是Dubbo在很多场景下都使用Provider、Consumer、Registry、Monitor划分逻辑拓普节点，保持统一概念。\n* 而Cluster是外围概念，所以Cluster的目的是将多个Invoker伪装成一个Invoker，这样其它人只要关注Protocol层Invoker即可，加上Cluster或者去掉Cluster对其它层都不会造成影响，因为只有一个提供者时，是不需要Cluster的。    \n* Proxy层封装了所有接口的透明化代理，而在其它层都以Invoker为中心，只有到了暴露给用户使用时，才用Proxy将Invoker转成接口，或将接口实现转成Invoker，也就是去掉Proxy层RPC是可以Run的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。    \n* 而Remoting实现是Dubbo协议的实现，如果你选择RMI协议，整个Remoting都不会用上，Remoting内部再划为Transport传输层和Exchange信息交换层，Transport层只负责单向消息传输，是对Mina、Netty、Grizzly的抽象，它也可以扩展UDP传输，而Exchange层是在传输层之上封装了Request-Response语义。    \n* Registry和Monitor实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。\n\n从上面的架构图中，我们可以了解到，Dubbo作为一个分布式服务框架，主要具有如下几个核心的要点：\n\n**服务定义**\n\n服务是围绕服务提供方和服务消费方的，服务提供方实现服务，而服务消费方调用服务。\n\n**服务注册**\n\n对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；对于服务消费方，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。而且，对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。\n\n通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。Dubbo提供的注册中心有如下几种类型可供选择：\n\n* Multicast注册中心\n* Zookeeper注册中心\n* Redis注册中心\n* Simple注册中心\n\n**服务监控**\n\n无论是服务提供方，还是服务消费方，他们都需要对服务调用的实际状态进行有效的监控，从而改进服务质量。\n\n**远程通信与信息交换**\n\n远程通信需要指定通信双方所约定的协议，在保证通信双方理解协议语义的基础上，还要保证高效、稳定的消息传输。Dubbo继承了当前主流的网络通信框架，主要包括如下几个：\n\n* Mina   \n* Netty    \n* Grizzly\n\n**服务调用**\n\n下面从Dubbo官网直接拿来，看一下基于RPC层，服务提供方和服务消费方之间的调用关系，如图所示：\n![1529978103528987](https://img.szpinc.org/2018-06-27-1529978103528987.jpg)\n\n上图中，蓝色的表示与业务有交互，绿色的表示只对Dubbo内部交互。点击这里可以了解更多架构设计图。上述图所描述的调用流程如下：\n\n* 服务提供方发布服务到服务注册中心；    \n* 服务消费方从服务注册中心订阅服务；    \n* 服务消费方调用已经注册的可用服务\n\n接着，将上面抽象的调用流程图展开，详细如图所示：\n![1529978103768057](https://img.szpinc.org/2018-06-27-1529978103768057.jpg)\n\n**注册/注销服务**\n\n服务的注册与注销，是对服务提供方角色而言，那么注册服务与注销服务的时序图，如图所示：\n![Dubbo的总体架构](https://img.szpinc.org/2018-06-27-1529978103556108.jpg)\n![1529978104606612](https://img.szpinc.org/2018-06-27-1529978104606612.jpg)\n\n**服务订阅/取消**\n\n为了满足应用系统的需求，服务消费方的可能需要从服务注册中心订阅指定的有服务提供方发布的服务，在得到通知可以使用服务时，就可以直接调用服务。反过来，如果不需要某一个服务了，可以取消该服务。下面看一下对应的时序图，如图所示：\n\n![1529978104143601](https://img.szpinc.org/2018-06-27-1529978104143601.jpg)\n\n**[协议支持](http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247486211&idx=1&sn=9af18f0057fe72f3507605d6e9519e7e&chksm=eb538e35dc24072323183ff9425885270dd7d8d51d118d86608fe24929e207c3ad7deb879336&scene=21#wechat_redirect)**\n\n* Dubbo协议\n* Hessian协议\n* HTTP协议\n* RMI协议\n* WebService协议\n* Thrift协议\n* Memcached协议\n* Redis协议\n\n在通信过程中，不同的服务等级一般对应着不同的服务质量，那么选择合适的协议便是一件非常重要的事情。你可以根据你应用的创建来选择。例如，使用RMI协议，一般会受到防火墙的限制，所以对于外部与内部进行通信的场景，就不要使用RMI协议，而是基于HTTP协议或者Hessian协议。\n\n参考补充\n\nDubbo以包结构来组织各个模块，各个模块及其关系，如图所示：\n\n![1529978104550711](https://img.szpinc.org/2018-06-27-1529978104550711.jpg)\n\n* 可以通过Dubbo的代码（使用Maven管理）组织，与上面的模块进行比较。简单说明各个包的情况：\n* dubbo-common 公共逻辑模块，包括Util类和通用模型。\n* dubbo-remoting 远程通讯模块，相当于Dubbo协议的实现，如果RPC用RMI协议则不需要使用此包。\n* dubbo-rpc 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。\n* dubbo-cluster 集群模块，将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。\n* dubbo-registry 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。\n* dubbo-monitor 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。\n* dubbo-config 配置模块，是Dubbo对外的API，用户通过Config使用Dubbo，隐藏Dubbo所有细节。\n* dubbo-container 容器模块，是一个Standalone的容器，以简单的Main加载Spring启动，因为服务通常不需要Tomcat/JBoss等Web容器的特性，没必要用Web容器去加载服务。\n\n","slug":"分布式-dubbo-架构设计详解","published":1,"updated":"2018-07-10T07:59:45.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjfplfju000xcwp6a4h03fnz","content":"<p>Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。关于注册中心、协议支持、服务监控等内容，详见后面描述。</p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484330&amp;idx=1&amp;sn=30f9cbb95821d06a3a5884edd8f1cb4f&amp;chksm=eb53869cdc240f8a237b975ec7f51817c020cfaacfaf48c6ac8a7bb9ca3516ee39db1847dfdf&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">总体架构</a></p>\n<p>Dubbo的总体架构，如图所示：<br><img src=\"https://img.szpinc.org/2018-06-27-1529978103556108.jpg\" alt=\"Dubbo的总体架构\"></p>\n<p>Dubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。点击这里可以了解更多架构设计图。</p>\n<p>下面，结合Dubbo官方文档，我们分别理解一下框架分层架构中，各个层次的设计要点：</p>\n<ol>\n<li>服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。    </li>\n<li>配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。</li>\n<li>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。</li>\n<li>服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。    </li>\n<li>集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。    </li>\n<li>监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。    </li>\n<li>远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。    </li>\n<li>信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。    </li>\n<li>网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。    </li>\n<li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。</li>\n</ol>\n<p>从上图可以看出，Dubbo对于服务提供方和服务消费方，从框架的10层中分别提供了各自需要关心和扩展的接口，构建整个服务生态系统（服务提供方和服务消费方本身就是一个以服务为中心的）。</p>\n<p><strong>根据官方提供的，对于上述各层之间关系的描述，如下所示：</strong></p>\n<ul>\n<li>在RPC中，Protocol是核心层，也就是只要有Protocol + Invoker + Exporter就可以完成非透明的RPC调用，然后在Invoker的主过程上Filter拦截点。</li>\n<li>图中的Consumer和Provider是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用Client和Server的原因是Dubbo在很多场景下都使用Provider、Consumer、Registry、Monitor划分逻辑拓普节点，保持统一概念。</li>\n<li>而Cluster是外围概念，所以Cluster的目的是将多个Invoker伪装成一个Invoker，这样其它人只要关注Protocol层Invoker即可，加上Cluster或者去掉Cluster对其它层都不会造成影响，因为只有一个提供者时，是不需要Cluster的。    </li>\n<li>Proxy层封装了所有接口的透明化代理，而在其它层都以Invoker为中心，只有到了暴露给用户使用时，才用Proxy将Invoker转成接口，或将接口实现转成Invoker，也就是去掉Proxy层RPC是可以Run的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。    </li>\n<li>而Remoting实现是Dubbo协议的实现，如果你选择RMI协议，整个Remoting都不会用上，Remoting内部再划为Transport传输层和Exchange信息交换层，Transport层只负责单向消息传输，是对Mina、Netty、Grizzly的抽象，它也可以扩展UDP传输，而Exchange层是在传输层之上封装了Request-Response语义。    </li>\n<li>Registry和Monitor实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</li>\n</ul>\n<p>从上面的架构图中，我们可以了解到，Dubbo作为一个分布式服务框架，主要具有如下几个核心的要点：</p>\n<p><strong>服务定义</strong></p>\n<p>服务是围绕服务提供方和服务消费方的，服务提供方实现服务，而服务消费方调用服务。</p>\n<p><strong>服务注册</strong></p>\n<p>对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；对于服务消费方，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。而且，对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。</p>\n<p>通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。Dubbo提供的注册中心有如下几种类型可供选择：</p>\n<ul>\n<li>Multicast注册中心</li>\n<li>Zookeeper注册中心</li>\n<li>Redis注册中心</li>\n<li>Simple注册中心</li>\n</ul>\n<p><strong>服务监控</strong></p>\n<p>无论是服务提供方，还是服务消费方，他们都需要对服务调用的实际状态进行有效的监控，从而改进服务质量。</p>\n<p><strong>远程通信与信息交换</strong></p>\n<p>远程通信需要指定通信双方所约定的协议，在保证通信双方理解协议语义的基础上，还要保证高效、稳定的消息传输。Dubbo继承了当前主流的网络通信框架，主要包括如下几个：</p>\n<ul>\n<li>Mina   </li>\n<li>Netty    </li>\n<li>Grizzly</li>\n</ul>\n<p><strong>服务调用</strong></p>\n<p>下面从Dubbo官网直接拿来，看一下基于RPC层，服务提供方和服务消费方之间的调用关系，如图所示：<br><img src=\"https://img.szpinc.org/2018-06-27-1529978103528987.jpg\" alt=\"1529978103528987\"></p>\n<p>上图中，蓝色的表示与业务有交互，绿色的表示只对Dubbo内部交互。点击这里可以了解更多架构设计图。上述图所描述的调用流程如下：</p>\n<ul>\n<li>服务提供方发布服务到服务注册中心；    </li>\n<li>服务消费方从服务注册中心订阅服务；    </li>\n<li>服务消费方调用已经注册的可用服务</li>\n</ul>\n<p>接着，将上面抽象的调用流程图展开，详细如图所示：<br><img src=\"https://img.szpinc.org/2018-06-27-1529978103768057.jpg\" alt=\"1529978103768057\"></p>\n<p><strong>注册/注销服务</strong></p>\n<p>服务的注册与注销，是对服务提供方角色而言，那么注册服务与注销服务的时序图，如图所示：<br><img src=\"https://img.szpinc.org/2018-06-27-1529978103556108.jpg\" alt=\"Dubbo的总体架构\"><br><img src=\"https://img.szpinc.org/2018-06-27-1529978104606612.jpg\" alt=\"1529978104606612\"></p>\n<p><strong>服务订阅/取消</strong></p>\n<p>为了满足应用系统的需求，服务消费方的可能需要从服务注册中心订阅指定的有服务提供方发布的服务，在得到通知可以使用服务时，就可以直接调用服务。反过来，如果不需要某一个服务了，可以取消该服务。下面看一下对应的时序图，如图所示：</p>\n<p><img src=\"https://img.szpinc.org/2018-06-27-1529978104143601.jpg\" alt=\"1529978104143601\"></p>\n<p><strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247486211&amp;idx=1&amp;sn=9af18f0057fe72f3507605d6e9519e7e&amp;chksm=eb538e35dc24072323183ff9425885270dd7d8d51d118d86608fe24929e207c3ad7deb879336&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">协议支持</a></strong></p>\n<ul>\n<li>Dubbo协议</li>\n<li>Hessian协议</li>\n<li>HTTP协议</li>\n<li>RMI协议</li>\n<li>WebService协议</li>\n<li>Thrift协议</li>\n<li>Memcached协议</li>\n<li>Redis协议</li>\n</ul>\n<p>在通信过程中，不同的服务等级一般对应着不同的服务质量，那么选择合适的协议便是一件非常重要的事情。你可以根据你应用的创建来选择。例如，使用RMI协议，一般会受到防火墙的限制，所以对于外部与内部进行通信的场景，就不要使用RMI协议，而是基于HTTP协议或者Hessian协议。</p>\n<p>参考补充</p>\n<p>Dubbo以包结构来组织各个模块，各个模块及其关系，如图所示：</p>\n<p><img src=\"https://img.szpinc.org/2018-06-27-1529978104550711.jpg\" alt=\"1529978104550711\"></p>\n<ul>\n<li>可以通过Dubbo的代码（使用Maven管理）组织，与上面的模块进行比较。简单说明各个包的情况：</li>\n<li>dubbo-common 公共逻辑模块，包括Util类和通用模型。</li>\n<li>dubbo-remoting 远程通讯模块，相当于Dubbo协议的实现，如果RPC用RMI协议则不需要使用此包。</li>\n<li>dubbo-rpc 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</li>\n<li>dubbo-cluster 集群模块，将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</li>\n<li>dubbo-registry 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</li>\n<li>dubbo-monitor 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。</li>\n<li>dubbo-config 配置模块，是Dubbo对外的API，用户通过Config使用Dubbo，隐藏Dubbo所有细节。</li>\n<li>dubbo-container 容器模块，是一个Standalone的容器，以简单的Main加载Spring启动，因为服务通常不需要Tomcat/JBoss等Web容器的特性，没必要用Web容器去加载服务。</li>\n</ul>\n","site":{"data":{"links":{"SZP博客":{"link":"https://blog.szpinc.org","avatar":"https://blog.szpinc.org/img/avatar.jpg","descr":"永远相信，美好的事情即将发生"}},"gallery":{"必应每日一图":{"full_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1920x1080.jpg","thumb_link":"http://s.cn.bing.net/az/hprichbg/rb/RestArea_ZH-CN13518721881_1280x720.jpg","desrc":"必应每日一图"}}}},"excerpt":"","more":"<p>Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。关于注册中心、协议支持、服务监控等内容，详见后面描述。</p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484330&amp;idx=1&amp;sn=30f9cbb95821d06a3a5884edd8f1cb4f&amp;chksm=eb53869cdc240f8a237b975ec7f51817c020cfaacfaf48c6ac8a7bb9ca3516ee39db1847dfdf&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">总体架构</a></p>\n<p>Dubbo的总体架构，如图所示：<br><img src=\"https://img.szpinc.org/2018-06-27-1529978103556108.jpg\" alt=\"Dubbo的总体架构\"></p>\n<p>Dubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。点击这里可以了解更多架构设计图。</p>\n<p>下面，结合Dubbo官方文档，我们分别理解一下框架分层架构中，各个层次的设计要点：</p>\n<ol>\n<li>服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。    </li>\n<li>配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。</li>\n<li>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。</li>\n<li>服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。    </li>\n<li>集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。    </li>\n<li>监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。    </li>\n<li>远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。    </li>\n<li>信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。    </li>\n<li>网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。    </li>\n<li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。</li>\n</ol>\n<p>从上图可以看出，Dubbo对于服务提供方和服务消费方，从框架的10层中分别提供了各自需要关心和扩展的接口，构建整个服务生态系统（服务提供方和服务消费方本身就是一个以服务为中心的）。</p>\n<p><strong>根据官方提供的，对于上述各层之间关系的描述，如下所示：</strong></p>\n<ul>\n<li>在RPC中，Protocol是核心层，也就是只要有Protocol + Invoker + Exporter就可以完成非透明的RPC调用，然后在Invoker的主过程上Filter拦截点。</li>\n<li>图中的Consumer和Provider是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用Client和Server的原因是Dubbo在很多场景下都使用Provider、Consumer、Registry、Monitor划分逻辑拓普节点，保持统一概念。</li>\n<li>而Cluster是外围概念，所以Cluster的目的是将多个Invoker伪装成一个Invoker，这样其它人只要关注Protocol层Invoker即可，加上Cluster或者去掉Cluster对其它层都不会造成影响，因为只有一个提供者时，是不需要Cluster的。    </li>\n<li>Proxy层封装了所有接口的透明化代理，而在其它层都以Invoker为中心，只有到了暴露给用户使用时，才用Proxy将Invoker转成接口，或将接口实现转成Invoker，也就是去掉Proxy层RPC是可以Run的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。    </li>\n<li>而Remoting实现是Dubbo协议的实现，如果你选择RMI协议，整个Remoting都不会用上，Remoting内部再划为Transport传输层和Exchange信息交换层，Transport层只负责单向消息传输，是对Mina、Netty、Grizzly的抽象，它也可以扩展UDP传输，而Exchange层是在传输层之上封装了Request-Response语义。    </li>\n<li>Registry和Monitor实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</li>\n</ul>\n<p>从上面的架构图中，我们可以了解到，Dubbo作为一个分布式服务框架，主要具有如下几个核心的要点：</p>\n<p><strong>服务定义</strong></p>\n<p>服务是围绕服务提供方和服务消费方的，服务提供方实现服务，而服务消费方调用服务。</p>\n<p><strong>服务注册</strong></p>\n<p>对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；对于服务消费方，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。而且，对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。</p>\n<p>通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。Dubbo提供的注册中心有如下几种类型可供选择：</p>\n<ul>\n<li>Multicast注册中心</li>\n<li>Zookeeper注册中心</li>\n<li>Redis注册中心</li>\n<li>Simple注册中心</li>\n</ul>\n<p><strong>服务监控</strong></p>\n<p>无论是服务提供方，还是服务消费方，他们都需要对服务调用的实际状态进行有效的监控，从而改进服务质量。</p>\n<p><strong>远程通信与信息交换</strong></p>\n<p>远程通信需要指定通信双方所约定的协议，在保证通信双方理解协议语义的基础上，还要保证高效、稳定的消息传输。Dubbo继承了当前主流的网络通信框架，主要包括如下几个：</p>\n<ul>\n<li>Mina   </li>\n<li>Netty    </li>\n<li>Grizzly</li>\n</ul>\n<p><strong>服务调用</strong></p>\n<p>下面从Dubbo官网直接拿来，看一下基于RPC层，服务提供方和服务消费方之间的调用关系，如图所示：<br><img src=\"https://img.szpinc.org/2018-06-27-1529978103528987.jpg\" alt=\"1529978103528987\"></p>\n<p>上图中，蓝色的表示与业务有交互，绿色的表示只对Dubbo内部交互。点击这里可以了解更多架构设计图。上述图所描述的调用流程如下：</p>\n<ul>\n<li>服务提供方发布服务到服务注册中心；    </li>\n<li>服务消费方从服务注册中心订阅服务；    </li>\n<li>服务消费方调用已经注册的可用服务</li>\n</ul>\n<p>接着，将上面抽象的调用流程图展开，详细如图所示：<br><img src=\"https://img.szpinc.org/2018-06-27-1529978103768057.jpg\" alt=\"1529978103768057\"></p>\n<p><strong>注册/注销服务</strong></p>\n<p>服务的注册与注销，是对服务提供方角色而言，那么注册服务与注销服务的时序图，如图所示：<br><img src=\"https://img.szpinc.org/2018-06-27-1529978103556108.jpg\" alt=\"Dubbo的总体架构\"><br><img src=\"https://img.szpinc.org/2018-06-27-1529978104606612.jpg\" alt=\"1529978104606612\"></p>\n<p><strong>服务订阅/取消</strong></p>\n<p>为了满足应用系统的需求，服务消费方的可能需要从服务注册中心订阅指定的有服务提供方发布的服务，在得到通知可以使用服务时，就可以直接调用服务。反过来，如果不需要某一个服务了，可以取消该服务。下面看一下对应的时序图，如图所示：</p>\n<p><img src=\"https://img.szpinc.org/2018-06-27-1529978104143601.jpg\" alt=\"1529978104143601\"></p>\n<p><strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247486211&amp;idx=1&amp;sn=9af18f0057fe72f3507605d6e9519e7e&amp;chksm=eb538e35dc24072323183ff9425885270dd7d8d51d118d86608fe24929e207c3ad7deb879336&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">协议支持</a></strong></p>\n<ul>\n<li>Dubbo协议</li>\n<li>Hessian协议</li>\n<li>HTTP协议</li>\n<li>RMI协议</li>\n<li>WebService协议</li>\n<li>Thrift协议</li>\n<li>Memcached协议</li>\n<li>Redis协议</li>\n</ul>\n<p>在通信过程中，不同的服务等级一般对应着不同的服务质量，那么选择合适的协议便是一件非常重要的事情。你可以根据你应用的创建来选择。例如，使用RMI协议，一般会受到防火墙的限制，所以对于外部与内部进行通信的场景，就不要使用RMI协议，而是基于HTTP协议或者Hessian协议。</p>\n<p>参考补充</p>\n<p>Dubbo以包结构来组织各个模块，各个模块及其关系，如图所示：</p>\n<p><img src=\"https://img.szpinc.org/2018-06-27-1529978104550711.jpg\" alt=\"1529978104550711\"></p>\n<ul>\n<li>可以通过Dubbo的代码（使用Maven管理）组织，与上面的模块进行比较。简单说明各个包的情况：</li>\n<li>dubbo-common 公共逻辑模块，包括Util类和通用模型。</li>\n<li>dubbo-remoting 远程通讯模块，相当于Dubbo协议的实现，如果RPC用RMI协议则不需要使用此包。</li>\n<li>dubbo-rpc 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</li>\n<li>dubbo-cluster 集群模块，将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</li>\n<li>dubbo-registry 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</li>\n<li>dubbo-monitor 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。</li>\n<li>dubbo-config 配置模块，是Dubbo对外的API，用户通过Config使用Dubbo，隐藏Dubbo所有细节。</li>\n<li>dubbo-container 容器模块，是一个Standalone的容器，以简单的Main加载Spring启动，因为服务通常不需要Tomcat/JBoss等Web容器的特性，没必要用Web容器去加载服务。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjjfplfik0000cwp6z3j9sknb","category_id":"cjjfplfiu0004cwp6lgdttqsv","_id":"cjjfplfj2000ccwp6sno76tf4"},{"post_id":"cjjfplfiw0006cwp6a9r718v8","category_id":"cjjfplfiu0004cwp6lgdttqsv","_id":"cjjfplfj7000icwp6idfmm8p7"},{"post_id":"cjjfplfir0002cwp6i2elnpx9","category_id":"cjjfplfj00009cwp6n79i2lq2","_id":"cjjfplfj8000ncwp6a3c76wzt"},{"post_id":"cjjfplfir0002cwp6i2elnpx9","category_id":"cjjfplfj5000fcwp69xub6qcu","_id":"cjjfplfj9000pcwp6jopchssr"},{"post_id":"cjjfplfjq000ucwp6ubrfi5ho","category_id":"cjjfplfj00009cwp6n79i2lq2","_id":"cjjfplfk7000zcwp6pj12l3jn"},{"post_id":"cjjfplfjq000ucwp6ubrfi5ho","category_id":"cjjfplfj5000fcwp69xub6qcu","_id":"cjjfplfk80011cwp6rexdc25g"},{"post_id":"cjjfplfju000xcwp6a4h03fnz","category_id":"cjjfplfj00009cwp6n79i2lq2","_id":"cjjfplfk90013cwp6nksxmdv8"},{"post_id":"cjjfplfju000xcwp6a4h03fnz","category_id":"cjjfplfj5000fcwp69xub6qcu","_id":"cjjfplfk90014cwp6pncl5mv4"},{"post_id":"cjjfplfjs000vcwp6m4nr47ak","category_id":"cjjfplfiu0004cwp6lgdttqsv","_id":"cjjfplfka0017cwp6ve8fqvsf"},{"post_id":"cjjfplfjs000vcwp6m4nr47ak","category_id":"cjjfplfk6000ycwp65kn4m1eq","_id":"cjjfplfkb0019cwp6cnezwr40"}],"PostTag":[{"post_id":"cjjfplfik0000cwp6z3j9sknb","tag_id":"cjjfplfiw0005cwp6g95riplg","_id":"cjjfplfj6000hcwp6822qtdgt"},{"post_id":"cjjfplfik0000cwp6z3j9sknb","tag_id":"cjjfplfj0000acwp67wb6kah1","_id":"cjjfplfj7000jcwp6l2rmprjf"},{"post_id":"cjjfplfik0000cwp6z3j9sknb","tag_id":"cjjfplfj2000ecwp6rac3sx8j","_id":"cjjfplfj8000lcwp6whrcucvb"},{"post_id":"cjjfplfir0002cwp6i2elnpx9","tag_id":"cjjfplfj6000gcwp6ht9bqv5d","_id":"cjjfplfj8000mcwp6skknl3vq"},{"post_id":"cjjfplfiw0006cwp6a9r718v8","tag_id":"cjjfplfiw0005cwp6g95riplg","_id":"cjjfplfja000rcwp6p086wjty"},{"post_id":"cjjfplfiw0006cwp6a9r718v8","tag_id":"cjjfplfj0000acwp67wb6kah1","_id":"cjjfplfja000scwp6hghkk9z8"},{"post_id":"cjjfplfiw0006cwp6a9r718v8","tag_id":"cjjfplfj2000ecwp6rac3sx8j","_id":"cjjfplfja000tcwp66tly7354"},{"post_id":"cjjfplfjq000ucwp6ubrfi5ho","tag_id":"cjjfplfju000wcwp62xazvbjt","_id":"cjjfplfk80012cwp6b3hpzeu4"},{"post_id":"cjjfplfjs000vcwp6m4nr47ak","tag_id":"cjjfplfj6000gcwp6ht9bqv5d","_id":"cjjfplfka0016cwp6bz9j1tl0"},{"post_id":"cjjfplfjs000vcwp6m4nr47ak","tag_id":"cjjfplfk80010cwp6q10xafu1","_id":"cjjfplfkb0018cwp6cb0mk21a"},{"post_id":"cjjfplfju000xcwp6a4h03fnz","tag_id":"cjjfplfj6000gcwp6ht9bqv5d","_id":"cjjfplfkd001bcwp6nhxjjpg4"},{"post_id":"cjjfplfju000xcwp6a4h03fnz","tag_id":"cjjfplfk90015cwp6c9x49vwq","_id":"cjjfplfkd001ccwp674fmd2jv"},{"post_id":"cjjfplfju000xcwp6a4h03fnz","tag_id":"cjjfplfkb001acwp6fiscbssx","_id":"cjjfplfkd001dcwp6er9v1u0w"}],"Tag":[{"name":"Docker","_id":"cjjfplfiw0005cwp6g95riplg"},{"name":"云计算","_id":"cjjfplfj0000acwp67wb6kah1"},{"name":"大数据","_id":"cjjfplfj2000ecwp6rac3sx8j"},{"name":"java","_id":"cjjfplfj6000gcwp6ht9bqv5d"},{"name":"springboot","_id":"cjjfplfju000wcwp62xazvbjt"},{"name":"spring","_id":"cjjfplfk80010cwp6q10xafu1"},{"name":"微服务","_id":"cjjfplfk90015cwp6c9x49vwq"},{"name":"dubbo","_id":"cjjfplfkb001acwp6fiscbssx"}]}}