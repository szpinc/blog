---
title: 冒泡排序的三种优化
date: 2019-01-09 10:01:20
tags:
    - 算法
    - 排序
categories:
    - 学习笔记
---

冒泡排序是最基础的一种交换排序法.

所谓冒泡,正如我们平时喝的汽水中的气泡一样,因为 CO2 比水轻,所以会一点一点往上冒.之所以打这个比喻,是因为恰好我们的冒泡排序类似于小气泡一般会根据本身的某种比较方式,一点一点的往数轴的右侧移动.如图:

![](https://img-blog.csdn.net/20180816221537821?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njg5NDg3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

依次从 0 开始往右侧比较.详见代码及执行结果:

``` java
public static void main(String[] args) {
        int[] array = new int[] { 5, 8, 6, 3, 9, 2, 1, 7, 4, 10, 12, 11 };
        sort1(array);
}
 
public static void sort1(int[] array) {
        int tmp = 0;
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - i - 1; j++) {
                System.out.println("第" + i + "轮:" + array[j] + "比较" + array[j + 1] + "[j=" + j + "]");
                if (array[j] > array[j + 1]) {
                    tmp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = tmp;
                }
            }
            System.out.println("第" + i + "轮结束:" + Arrays.toString(array));
        }
        System.out.println(Arrays.toString(array));
}
```

```
第0轮:5比较8[j=0]
第0轮:8比较6[j=1]
第0轮:8比较3[j=2]
第0轮:8比较9[j=3]
第0轮:9比较2[j=4]
第0轮:9比较1[j=5]
第0轮:9比较7[j=6]
第0轮:9比较4[j=7]
第0轮:9比较10[j=8]
第0轮:10比较12[j=9]
第0轮:12比较11[j=10]
第0轮结束:[5, 6, 3, 8, 2, 1, 7, 4, 9, 10, 11, 12]
第1轮:5比较6[j=0]
第1轮:6比较3[j=1]
第1轮:6比较8[j=2]
第1轮:8比较2[j=3]
第1轮:8比较1[j=4]
第1轮:8比较7[j=5]
第1轮:8比较4[j=6]
第1轮:8比较9[j=7]
第1轮:9比较10[j=8]
第1轮:10比较11[j=9]
第1轮结束:[5, 3, 6, 2, 1, 7, 4, 8, 9, 10, 11, 12]
第2轮:5比较3[j=0]
第2轮:5比较6[j=1]
第2轮:6比较2[j=2]
第2轮:6比较1[j=3]
第2轮:6比较7[j=4]
第2轮:7比较4[j=5]
第2轮:7比较8[j=6]
第2轮:8比较9[j=7]
第2轮:9比较10[j=8]
第2轮结束:[3, 5, 2, 1, 6, 4, 7, 8, 9, 10, 11, 12]
第3轮:3比较5[j=0]
第3轮:5比较2[j=1]
第3轮:5比较1[j=2]
第3轮:5比较6[j=3]
第3轮:6比较4[j=4]
第3轮:6比较7[j=5]
第3轮:7比较8[j=6]
第3轮:8比较9[j=7]
第3轮结束:[3, 2, 1, 5, 4, 6, 7, 8, 9, 10, 11, 12]
第4轮:3比较2[j=0]
第4轮:3比较1[j=1]
第4轮:3比较5[j=2]
第4轮:5比较4[j=3]
第4轮:5比较6[j=4]
第4轮:6比较7[j=5]
第4轮:7比较8[j=6]
第4轮结束:[2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
第5轮:2比较1[j=0]
第5轮:2比较3[j=1]
第5轮:3比较4[j=2]
第5轮:4比较5[j=3]
第5轮:5比较6[j=4]
第5轮:6比较7[j=5]
第5轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
第6轮:1比较2[j=0]
第6轮:2比较3[j=1]
第6轮:3比较4[j=2]
第6轮:4比较5[j=3]
第6轮:5比较6[j=4]
第6轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
第7轮:1比较2[j=0]
第7轮:2比较3[j=1]
第7轮:3比较4[j=2]
第7轮:4比较5[j=3]
第7轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
第8轮:1比较2[j=0]
第8轮:2比较3[j=1]
第8轮:3比较4[j=2]
第8轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
第9轮:1比较2[j=0]
第9轮:2比较3[j=1]
第9轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
第10轮:1比较2[j=0]
第10轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
第11轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
```

由上代码可发现,执行了 11 次,每次由index=0 的位置开始向右侧比较.此时发现一个问题,其实在第五轮比较的时候,此时元素已经是有序的了,所以可以得出结论,在原始的冒泡排序当中,排序次数和元素的数量相当,所以时间复杂度为 O(n^2).

上例排序中,出现多次的程序在做 "无用功" 耗时的情况,所以可以优化代码为:

``` java
public static void main(String[] args) {
    int[] array = new int[]{5, 8, 6, 3, 9, 2, 1, 7, 4, 10, 11, 12};
    sort2(array);
}

public static void sort2(int[] array) {
    int tmp = 0;
    for (int i = 0; i < array.length; i++) {
        // 有序标记，每一轮的初始是true
        boolean flag = true;
        for (int j = 0; j < array.length - i - 1; j++) {
            System.out.println("第" + i + "轮:" + array[j] + "比较" + array[j + 1] + "[j=" + j + "]");
            if (array[j] > array[j + 1]) {
                tmp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = tmp;
                //有元素交换，所以不是有序，标记变为false
                flag = false;
            }
        }
        System.out.println("第" + i + "轮结束:" + Arrays.toString(array) + " 有序:" + flag);
        if (flag) {
            break;
        }
    }
    System.out.println(Arrays.toString(array));
}
```

```
第0轮:5比较8[j=0]
第0轮:8比较6[j=1]
第0轮:8比较3[j=2]
第0轮:8比较9[j=3]
第0轮:9比较2[j=4]
第0轮:9比较1[j=5]
第0轮:9比较7[j=6]
第0轮:9比较4[j=7]
第0轮:9比较10[j=8]
第0轮:10比较11[j=9]
第0轮:11比较12[j=10]
第0轮结束:[5, 6, 3, 8, 2, 1, 7, 4, 9, 10, 11, 12] 有序:false
第1轮:5比较6[j=0]
第1轮:6比较3[j=1]
第1轮:6比较8[j=2]
第1轮:8比较2[j=3]
第1轮:8比较1[j=4]
第1轮:8比较7[j=5]
第1轮:8比较4[j=6]
第1轮:8比较9[j=7]
第1轮:9比较10[j=8]
第1轮:10比较11[j=9]
第1轮结束:[5, 3, 6, 2, 1, 7, 4, 8, 9, 10, 11, 12] 有序:false
第2轮:5比较3[j=0]
第2轮:5比较6[j=1]
第2轮:6比较2[j=2]
第2轮:6比较1[j=3]
第2轮:6比较7[j=4]
第2轮:7比较4[j=5]
第2轮:7比较8[j=6]
第2轮:8比较9[j=7]
第2轮:9比较10[j=8]
第2轮结束:[3, 5, 2, 1, 6, 4, 7, 8, 9, 10, 11, 12] 有序:false
第3轮:3比较5[j=0]
第3轮:5比较2[j=1]
第3轮:5比较1[j=2]
第3轮:5比较6[j=3]
第3轮:6比较4[j=4]
第3轮:6比较7[j=5]
第3轮:7比较8[j=6]
第3轮:8比较9[j=7]
第3轮结束:[3, 2, 1, 5, 4, 6, 7, 8, 9, 10, 11, 12] 有序:false
第4轮:3比较2[j=0]
第4轮:3比较1[j=1]
第4轮:3比较5[j=2]
第4轮:5比较4[j=3]
第4轮:5比较6[j=4]
第4轮:6比较7[j=5]
第4轮:7比较8[j=6]
第4轮结束:[2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 有序:false
第5轮:2比较1[j=0]
第5轮:2比较3[j=1]
第5轮:3比较4[j=2]
第5轮:4比较5[j=3]
第5轮:5比较6[j=4]
第5轮:6比较7[j=5]
第5轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 有序:false
第6轮:1比较2[j=0]
第6轮:2比较3[j=1]
第6轮:3比较4[j=2]
第6轮:4比较5[j=3]
第6轮:5比较6[j=4]
第6轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 有序:true
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
```

这里修改原本的代码增加一个标志位,标记本轮排序中,元素有没有交换,若有交换则表明元素无序,反之则反之.

通过打印语句可以看出,在第六轮的时候,发现元素(从 0 序号开始!!!!!)无更改,表明数列有序,即 break;

但是,此时根据第 0/1/2 轮可以看出,10,11,12 本身即有序,依旧做了比较(在实际的比较中,出现本身有序的数列可能更多) ,由此又引出一个问题排序过程的已有序数列已经在比较位置,因此修改代码如下:

``` java
public static void sort3(int[] array){
    int tmp = 0;
    //记录最后一次交换的位置
    int lastChangeIndex = 0;
    //无序数列的边界，每次比较只需要比到这里为止
    int border = array.length - 1;
    for (int i = 0; i < array.length; i++) {
        // 有序标记，每一轮的初始是true
        boolean flag = true;
        for (int j = 0; j < border; j++) {
            System.out.println("第" + i + "轮:" + array[j] + "比较" + array[j + 1] + "[j=" + j + "]");
            if (array[j] > array[j + 1]) {
                tmp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = tmp;
                //有元素交换，所以不是有序，标记变为false
                flag = false;
                //把无序数列的边界更新为最后一次交换元素的位置
                lastChangeIndex = j;
            }
        }
        System.out.println("第" + i + "轮结束:" + Arrays.toString(array) + "边界为:" + lastChangeIndex);
        border = lastChangeIndex;
        if(flag){
            break;
        }
    }
    System.out.println(Arrays.toString(array));
}
```

```
第0轮:5比较8[j=0]
第0轮:8比较6[j=1]
第0轮:8比较3[j=2]
第0轮:8比较9[j=3]
第0轮:9比较2[j=4]
第0轮:9比较1[j=5]
第0轮:9比较7[j=6]
第0轮:9比较4[j=7]
第0轮:9比较10[j=8]
第0轮:10比较11[j=9]
第0轮:11比较12[j=10]
第0轮结束:[5, 6, 3, 8, 2, 1, 7, 4, 9, 10, 11, 12]边界为:7
第1轮:5比较6[j=0]
第1轮:6比较3[j=1]
第1轮:6比较8[j=2]
第1轮:8比较2[j=3]
第1轮:8比较1[j=4]
第1轮:8比较7[j=5]
第1轮:8比较4[j=6]
第1轮结束:[5, 3, 6, 2, 1, 7, 4, 8, 9, 10, 11, 12]边界为:6
第2轮:5比较3[j=0]
第2轮:5比较6[j=1]
第2轮:6比较2[j=2]
第2轮:6比较1[j=3]
第2轮:6比较7[j=4]
第2轮:7比较4[j=5]
第2轮结束:[3, 5, 2, 1, 6, 4, 7, 8, 9, 10, 11, 12]边界为:5
第3轮:3比较5[j=0]
第3轮:5比较2[j=1]
第3轮:5比较1[j=2]
第3轮:5比较6[j=3]
第3轮:6比较4[j=4]
第3轮结束:[3, 2, 1, 5, 4, 6, 7, 8, 9, 10, 11, 12]边界为:4
第4轮:3比较2[j=0]
第4轮:3比较1[j=1]
第4轮:3比较5[j=2]
第4轮:5比较4[j=3]
第4轮结束:[2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]边界为:3
第5轮:2比较1[j=0]
第5轮:2比较3[j=1]
第5轮:3比较4[j=2]
第5轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]边界为:0
第6轮结束:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]边界为:0
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
```

此时我们使用 border 标记边界(即,最右侧的有序数列的左边界),标记处的序号之后的元素就无需再进行比较了,减少了比较次数,对于原始的冒泡排序优化.